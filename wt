#!/usr/bin/perl

=pod

=head1 NAME

wt - command line work log client

=head1 SYNOPSIS

Available subcommands:

    wt [add] [-d DATE|-y] [-c] [-f] [-a ACTIVITY] INTERVAL ISSUE COMMENT
    wt commit
    wt start [-c] [ISSUE] [COMMENT]
    wt report [START] [END] [ISSUE]
    wt rm [-r] INDEX|all
    wt issues [-a] [-s|-j] [-m NUM] STRING
    wt alias [ALIAS [COMMAND ...]]
    wt
    wt help [SUBCOMMAND]


=head1 DESCRIPTION

B<wt> can be used to track, log, and query working time with a convenient
command line interface.
Working time entries (discrete intervals with a starting and ending time)
are first collected in a local database, then committed to a JIRA instance.
Work log entries previously committed, as well as JIRA issue names and
descriptions, can be queried.

=head1 SUBCOMMANDS

=head2 ADD

    wt [add] [-d DATE|-y] [-c] [-f] [-a ACTIVITY] INTERVAL ISSUE COMMENT

Adds an entry to the local list of wt entries.

=head3 There are three mandatory arguments:

=over

=item Interval

Starting and ending time in B<HH:MM:SS> format, separated by a dash.

	[HH[:MM[:SS]]]-[HH[:MM[:SS]]]

If seconds are omitted, B<HH:MM:00> is assumed (whole minutes).
If minutes are omitted, B<HH:00:00> is assumed (whole hours).

If the starting time is omitted altogether, 
the saved start mark is used instead, if available.
It is an error to omit the start if no start mark is available.

If the ending time is omitted altogether, the current time is assumed.

The ending time is also saved for the start mark of the next
C<wt add> command. Thus, the interval argument may consist of 
just a single dash in certain cases, meaning 
"from the end of the last entry till now".

Alternatively, a relative interval may be specified with a C<+> (plus sign)
and a time specifier (B<HH:MM:SS>). Minutes and seconds may be omitted.
Fractional hours may also be specified. A C<m> suffix means minutes.

	+HH[:MM[:SS]]
	+HH.H
	+MMm

Starting time is taken from the start mark. The command fails if there
is no start mark available.

=item Issue

Project or issue identifier, in B<PROJECT-NUMBER> format.
A single dash means to use the current project, if one is available.

=item Comment

Arbitrary text (can contain spaces etc. if quoted) to describe
the task/bugfix etc.
A single dash means to repeat the comment for the last entry (or the
comment saved with C<wt start>), if one is available.

=back

=head3 Options to the B<add> subcommand

=over

=item C<-a> Activity type

JIRA requires an activity type for each worklog entry. This can be
overridden with the C<-a> or C<--activity> switch.
The default activity type is "Dev".

=item C<-d> Set date

By default, the date for the entry is the current date. This can be overridden
by the C<-d> or C<--date> switch, which requires a date string in YYYY-MM-DD format. 
If the year or month is omitted, the current year or month is substituted.

=item C<-y> Yesterday

The C<-y> or C<--yesterday> switch sets the date to yesterday.

=item C<-c> Autocommit

By default, the C<add> subcommand only adds the entry to the local list, 
which must be committed with C<wt commit> separately.

This switch causes the entry to be committed immediately.

=item C<-f> Force

By default, a new entry that overlaps with any previous (local) entry is
rejected. This switch can be used to disable this check
(JIRA doesn't seem to care anyway).

=back

=head3 Lunch and breaks

Specifying "lunch" as the issue name will cause the following:

=over

=item The project name will be substituted from the "lunch-project" key in 
wt.conf. If that key doesn't exist, the program terminates with an error.

=item The comment becomes optional, if omitted, "lunch" will be substituted.

=item The activity type will be set to "Break" unless explicitly overridden.

=back

The C<add> keyword may be omitted.

=head2 COMMIT

    wt commit
    wt ci

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt start [-c|--change] [ISSUE] [COMMENT]
	wt s ...

Saves a timestamp with the current time. In effect, this command means
"I'm starting work now". An optional project (issue) name can be specified,
it will be saved as the current project.

The C<--change> or C<-c> option only changes the current issue, but does not
reset the timestamp.

=head2 REPORT

    wt report [START] [END] [PROJECT]
    wt r ...

Queries worklog entries from JIRA.
If this subcommand is called with two date arguments, worklog entries between the two date
are queried from JIRA. Dates must be specified as YYYY-MM-DD.
If the year or month is omitted, the current year or month is substituted.
C<today> can be used to mean the current date.

The end date may be omitted altogether, in which case the current date is assumed.

An optional third argument can be used to filter for project name.

If called without dates, prints the results of the last query
(but doesn't start a new query).

=head2 ISSUES

    wt issues [-a] [-s|-j] [-m NUM] [STRING]
    wt : ...

Query issues matching STRING from JIRA and print the resulting list.

Each entry contains the issue number, status, assignee and summary.

The list is sorted by date, latest is on the bottom.

If STRING looks like a JIRA issue (e.g. CG-54), it is assumed to be an issue number,
and the resulting list will contain that one issue (at most).
Otherwise, it is assumed to be a project number, and all issues under that project
are returned (if the project exists).

The -s or --summary switch can be used to search in the issue summaries instead.
In this case all issues are reported whose summaries match STRING.

Alternatively, the -j or --jql switch can be used to pass a raw JQL query string to JIRA.
The query string is not validated, just passed as is.

The -a or --assigned switch can be used to restrict the search to those issues 
that are assigned to the current user.

The -m or --max switch can be used to override the maximum number of issues reported, 
by default 100.

=head2 RM

    wt rm [-r] INDEX|all

Without the -r or --remote switch, this subcommand deletes one local wt entry.
The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

With the -r or --remote switch, this subcommand does something completely
different: it removes an already committed entry from JIRA.

In this case the INDEX argument is understood as the index of the entry
in the list of B<remote> entries, as reported by the last C<wt query> command.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.

=head2 ALIAS

    wt alias [ALIAS [COMMAND ...]]

This subcommand can be used to assign shortcuts to frequently used commands.

If called as e.g. C<wt alias foo add - ISSUE-1 foo>, then from that point
C<wt foo> will be understood as an alias for C<wt add - ISSUE-1 foo>.

Aliases are not expanded recursively, so only the default subcommands are
allowed as the aliased command. However, any string is accepted as an alias,
so even the default subcommands can be redefined.

If called with just an alias but without a definition, that alias is deleted.

If called without any parameters, the list of all defined aliases is printed.

=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=head1 EXAMPLES

A typical session (working day) begins with issuing the

	wt start

command, optionally with a JIRA issue identifier, to signify that you're
starting work for the day.

The simplest way to log time is right away when you're finished with a work unit
(bugfix, feature etc.):

	wt add - - implemented foo in module bar

This command means in essence I<I've worked on the current issue, from the
end of the last entry till now>.

Work can be continued to be logged in this way until the end of the day,
when you finally commit the day's work to JIRA:

	wt commit

This is not mandatory, however, you can also opt to record your work log
entries in one go at the end of the day, specifying explicit intervals
and issue names:

	wt add 9-12:30 BAR-42 implemented foo in module bar

or even

	wt +50m BAR-42 foo

if you don't care about exact starting and ending times, 
just the amount of time.

You can use

	wt : BAR

to search for issues in project BAR.

=head1 FILES

This program relies on two files called F<wt.conf> and F<wt.state>,
used to store user preferences and persistent state, respectively.

These files are expected to be in a directory called F<.wt> under the user's
home directory.

F<wt.conf>, the configuration file should be edited by the user before
attempting to use the program. It must be a valid JSON file.
The JSON object in it must have at least the following keys:

=over

=item jira_base_url

The base URL of the JIRA instance to which the worklog entries are to be
sent.

=item user_name

A valid JIRA user name, to be used for authentication.

=back

The following optional keys are also recognized:

=over

=item worklog_url

Override the standard REST API endpoint used by JIRA to submit/query
worklog entries

=item search_url

Override the standard REST API endpoint used by JIRA to search issues

=item lunch_project

Specify a JIRA issue for the C<wt add - lunch> feature

=item autocommit

Turns on autocommit mode: C<commit> is called after each invocation of 
<wt add>. Boolean key.

=item no_overlap_check

Disables checking for overlapping time intervals in C<wt add>. Boolean key.

=back


Example:

	{
			"jira_base_url": "https://my.awesome.company.com/jira",
			"worklog_url": "/rest/tempo-timesheets/3/worklogs/",
			"search_url": "/rest/api/2/search",
			"user_name": "homer.simpson",
			"lunch_project": "CMPS-19",
			"autocommit": true
	}

F<wt.state>, the file to store persistent state between consequent runs
of the program, is modified by most subcommands (the exceptions are C<wt>
without arguments and C<wt report> without arguments). It is also a JSON
file, however, it is not intended to be directly edited by the user.

=head1 SAVING JIRA PASSWORD

The C<commit>, C<issues>, C<rm --remote> and C<report> subcommand have to connect to 
the JIRA instance specified in the config file. This requires authentication,
in the form of an user name and password. The user name is also specified
in the config file, however, the password is not.

On systems that have a keyring (more precisely, any working keyring 
implementation supported by the Passwd::Keyring::Auto module, which must
also be installed if keyring support is desired), the password is asked only once, then saved into the
keyring safely.

On systems without keyring support the JIRA password is asked before every
command that needs JIRA access.

Storing the password in plaintext is not supported (nor is it recommended).

=cut

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;
use DateTime;
use Getopt::Long;
use Encode::Locale;
use Encode;

# keyring support is optional, will be enabled only
# if the module is installed
our $have_keyring;
BEGIN {
	$have_keyring = eval {
		require Passwd::Keyring::Auto;
		Passwd::Keyring::Auto->import();
		1;
	};
}

# load config and state
my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);
my $ret = 0;

# take care of encoding for output...
binmode STDOUT, ":encoding(UTF-8)";

# and for input as well
@ARGV = map { decode(locale => $_, 1) } @ARGV;

# get subcommand
my $action = shift @ARGV;

# take aliases into account
if (defined $action and exists $state->{aliases}{$action}) {
	my @cmds = @{$state->{aliases}{$action}};
	$action = shift @cmds;
	unshift @ARGV, @cmds;
}

# jump table for subcommands
for ($action) {
	when (undef)           { list_local(); }
	when ([qw/issues :/])  { get_issues(); }
	when ([qw/alias al/ ]) { set_alias();  }
	when ([qw/start  s/ ]) { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	when (/^[\-\d\+]/)     { unshift @ARGV, $action; add(); }
	default                { help();       }
}

exit($ret);

###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/alias al/ ]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ALIAS"});  }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"}); }
		when ([qw/issues :/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ISSUES"}); }
		when ([qw/report r/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/add a/])     { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ADD"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (
		map {$_->[1]}
		sort { $a->[0] cmp $b->[0] }
		map { [(join "\t",
			_print_date($_->{date}),
			_print_time($_->{start_time}),
			_print_time($_->{end_time}) ), $_] }
		@{$state->{local}}) {
			print print_wtline($wt, $i++);
	}
	if (@{$state->{local}}) {
		say "";
		say summary($state->{local});
	}
	else {
		say "No local wt records.";
		$ret = 1;
	}

	print_unlogged();
}

sub set_alias {
	my $alias = shift @ARGV;

	if (defined $alias) {
		if (@ARGV) {
			$state->{aliases}{$alias} = [@ARGV];
		}
		else {
			delete $state->{aliases}{$alias};
		}
		save_state($state_fn, $state);
	}
	else {
		if (keys %{$state->{aliases}}) {
			while (my ($al, $def) = each %{$state->{aliases}}) {
				say $al, ":\t@$def";
			}
		}
		else {
			say "No defined aliases.";
			$ret = 1;
		}
	}
}

sub rm {
	my $remote = 0;
	GetOptions(
		'remote!'  => \$remote,
	) or help('rm');
	
	my $idx = shift @ARGV;
	if ($remote) {
		die "Error: specify the index of remote wt record to be deleted" unless $idx;
		die "Error: no remote wt records to delete\n" unless scalar @{$state->{remote}};

		my $pw = get_pw();

		if ($idx eq "all") {
			_rm_one_remote($_, $pw) for 0..$#{$state->{remote}};
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{remote}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{remote}};
			_rm_one_remote($idx-1, $pw);
		}
		# delete remote entries locally that were successfully deleted remotely
		$state->{remote} = [ grep { not exists $_->{deleted} } @{$state->{remote}} ];
		save_state($state_fn, $state);
		list_remote(on_error => "No remote worklog records.");
 	}
	else {
		die "Error: specify the index of local wt record to be deleted" unless $idx;
		die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};

		if ($idx eq "all") {
			$state->{local} = [];
			say "All local wt records deleted!";
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{local}};
			# at this point we should have a valid index to delete
			splice @{$state->{local}}, $idx-1, 1;
			
			# update start mark to end of last entry
			if (@{$state->{local}}) {
				$state->{current_project} = $state->{local}[-1]{project};
				$state->{start_mark} = { t => $state->{local}[-1]{end_time}, d => $state->{local}[-1]{date} };
			}
		}
		save_state($state_fn, $state); 
		list_local();
	}
}

sub set_mark {
	my $change = 0;
	GetOptions(
		'change!' => \$change,
	) or help('start');

	unless ($change) {
		$state->{start_mark} = { t => parse_time(undef), d => parse_date(undef) };
	}

	my $project_str = shift @ARGV;
	if (defined $project_str) {
		$state->{current_project} = uc $project_str;
	}
	elsif ($change) {
		$project_str //= "";
		die "Error: project name required for wt start --change\n";
	}

	$state->{current_comment} = "@ARGV" if @ARGV;

	if ($change) {
		print_unlogged();
	}
	else {
		my $on_project =  defined $state->{current_project} ? "on issue $state->{current_project}" : "";
		say "Started work $on_project";
	}

	save_state($state_fn, $state); 
}

sub commit {
	my $pw = get_pw();

	for my $wtline (@{$state->{local}}) {
		my $json = wtline_to_jira_json($wtline);
		my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};
		my $req = HTTP::Request->new('POST', $worklog_url);
		$req->header('Content-Type' => 'application/json');
		$req->authorization_basic($config->{user_name}, $pw);
		$req->content($json);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);
		
		if ( $response->is_success() ) {
			# mark locally stored wt line if commit was successful
			$wtline->{committed} = 1;
		}
		else {
			_handle_jira_error($response);
		}
	}
	# delete wt lines that were successfully committed
	$state->{local} = [ grep { not exists $_->{committed} } @{$state->{local}} ];

	save_state($state_fn, $state);
}

sub query {
	my $start_date_str = shift @ARGV;
	
	if (defined $start_date_str) {
		$start_date_str = undef if $start_date_str eq 'today';
		my $start_date = parse_date($start_date_str);
		help('report') unless defined $start_date;

		my $end_date_str = shift @ARGV;
		my $end_date = parse_date($end_date_str);

		my $project = shift @ARGV;

		my $pw = get_pw();

		my $url = $config->{jira_base_url}.$config->{worklog_url};

		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date), username => $config->{user_name});
		$query_hash{projectKey} = $project if defined $project;
		my $query_string = uri_escape_hash(%query_hash);

		my $req = HTTP::Request->new('GET', $url."?".$query_string);
		$req->authorization_basic($config->{user_name}, $pw);

		my $ua = LWP::UserAgent->new;
		my $response = $ua->request($req);

		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;

			update_saved_issue_summaries($state->{remote}, from => 'remote');

			list_remote(on_error => "No worklog records in the specified date range.");

			save_state($state_fn, $state);
		}
		else {
			_handle_jira_error($response);
		}
		
	}
	else {
		# print last saved query, don't actually ask jira
		list_remote(on_error => "There is no saved query.");
	} 

}

sub get_issues {
	my $assigned_to_me = 0;
	my $summary = 0;
	my $max = 100;
	my $raw_jql;
	GetOptions(
		'assigned!' => \$assigned_to_me,
		'summary!'  => \$summary,
		'max=i'     => \$max,
		'jql=s'     => \$raw_jql,
	) or help('issues');

	my $filter = shift @ARGV;
	my @jql;
	if (defined $filter) {
		if ($raw_jql) {
			push @jql, $filter;
		}
		elsif ($summary) {
			push @jql, "summary ~ $filter";
		}
		elsif ($filter =~ /\w+-\d+/) {
			push @jql, "issue = $filter";
		}
		else {
			push @jql, "project = $filter";
		}
	}
	if ($assigned_to_me) {
		push @jql, "assignee = " . $config->{user_name};
	}
	my $jql = join " and ", @jql;
	$jql .= " order by createddate desc" if $jql;

	my $pw = get_pw();
	
	my $json = encode_json {
		"jql" => $jql,
		"startAt" => 0,
		"maxResults" => $max,
		"fields" => [
			"summary",
			"status",
			"assignee"
		]
	};
	my $jira_url = $config->{jira_base_url}.$config->{search_url};
	my $req = HTTP::Request->new('POST', $jira_url);
	$req->header('Content-Type' => 'application/json;charset=UTF-8');
	$req->authorization_basic($config->{user_name}, $pw);
	$req->content($json);

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);
	
	if ( $response->is_success() ) {
		my $raw_data = decode_json $response->decoded_content;
		say for reverse map { 
				sprintf "%-8s%-16s%-16s%s", 
					$_->{key}, 
					_trunc($_->{fields}{status}{name}, 15), 
					$_->{fields}{assignee}{name} // "", 
					$_->{fields}{summary}
				} 
			@{$raw_data->{issues}};

		update_saved_issue_summaries($raw_data->{issues}, from => 'issuelist');
		save_state($state_fn, $state);
	}
	else {
		_handle_jira_error($response);
	}
	
}

sub add {
	help("add") unless defined $ARGV[0];

	# get current date as default
	my $date = parse_date(undef);

	# defaults
	my $autocommit = 0;
	my $no_overlap_check = 0;
	my $activity = undef;

	# need to check if first arg is interval spec (single dash or dash-number)
	# before calling GetOptions
	Getopt::Long::Configure(qw/no_ignore_case pass_through/);
	unless ($ARGV[0] =~ /^\-$|^\-\d|^\+/) {
		GetOptions(
			'date=s'     => sub { $date = parse_date($_[1]); },
			'yesterday!' => sub { $date = _yesterday(); },
			'commit!'    => \$autocommit,
			'activity=s' => \$activity,
			'force!'     => \$no_overlap_check,
		);
		help('add') if @ARGV and $ARGV[0] =~ /-[^0-9]/;
	}

	# first argument: from-to time or relative interval
	my $interval = shift @ARGV;
	die "Error: missing time or interval spec\n" unless defined $interval;
	my ($start_time, $end_time);

	# relative interval
	if (index($interval, '+') == 0) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark}{t};
		}
		else {
			die "Error: no saved starting time available, you must specify the interval explicitly\n";
		}
		my $t = parse_time($interval);

		$end_time = increment_time($start_time, time_spent({H=>0, M=>0, S=>0}, $t));
	}
	# absolute interval
	else {
		my ($s, $e) = split '-', $interval;

		# If from is not specified, try to use saved start mark.
		# If there is no start mark either, give up.
		if (not defined $s or $s eq '') {
			if (defined $state->{start_mark}) {
				$start_time = $state->{start_mark}{t};
			}
			else {
				die "Error: no saved starting time available, you must specify it explicitly\n";
			}
		}
		else {
			$start_time = parse_time($s);
		}
		# end time falls back to current time if not specified
		$end_time = parse_time($e);
	}

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		elsif ($project_str eq "lunch") {
			# special hack: shortcut for lunch
			$project = $config->{lunch_project};
			die "Error: lunch project is not defined, edit wt.conf\n" unless defined $project;
		}
		else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";
	}
	$project = uc $project;

	# third argument: comment
	# rest of @ARGV is concatenated so that quotes are not needed
	my $comment = "@ARGV";
	# special hack: no comment is required for lunch
	$comment = "lunch" if $comment eq '' and $project_str eq "lunch";
	die "Error: Comment is required\n" if $comment eq '';
	# use saved comment if one is available and explicitly requested
	$comment = $state->{current_comment} if $comment eq '-' and defined $state->{current_comment};
	# and save current comment for future use
	$state->{current_comment} = $comment;

	# activity may have been set by option
	# special hack: no comment is required for lunch
	$activity = "Break" if not defined $activity and $project_str eq "lunch";
	$activity //= 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
	};

	if (not ($no_overlap_check or $config->{no_overlap_check})
	and my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef);
	}

	push @{$state->{local}}, $wtline;
	
	$state->{current_project} = $project;
	$state->{start_mark} = { t => $end_time, d => $date };

	save_state($state_fn, $state);
	list_local();

	if ($autocommit or $config->{autocommit}) {
		commit();
	}
}

###############

sub _rm_one_remote {
	my $idx = shift;
	my $pw = shift;

	my $id = $state->{remote}[$idx]{id};
	my $worklog_url = $config->{jira_base_url}.$config->{worklog_url}.$id.'/';
	my $req = HTTP::Request->new('DELETE', $worklog_url);
	$req->authorization_basic($config->{user_name}, $pw);

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);

	if ( $response->is_success() ) {
		# mark locally stored remote entry if delete was successful
		$state->{remote}[$idx]->{deleted} = 1;
	}
	else {
		_handle_jira_error($response);
	}
}

###############

sub _load_json {
	my ($fn) = @_;
	open(my $FH, "<", $fn) or return undef;
	my $json = join "", <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	die "Missing key from config file: jira_base_url\n" unless defined $config->{jira_base_url};
	die "Missing key from config file: user_name\n" unless defined $config->{user_name};
	$config->{worklog_url} //= "/rest/tempo-timesheets/3/worklogs/";
	$config->{search_url}  //= "/rest/api/2/search";

	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	return _save_json($_[0], $_[1], "state");
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			key => uc $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		billedSeconds => 0,
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => { 
			name => $config->{user_name} 
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;
	
	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});
	
	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jira->{worklogAttributes}[0]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';
	
	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

sub update_saved_issue_summaries {
	my $issuelist = shift;
	my %args = @_;

	my %actions = (
		remote => sub {
				$state->{issues}->{ $_->{issue}{key} } = $_->{issue}{summary} for @_;
			},
		issuelist => sub {
				$state->{issues}->{ $_->{key} } = $_->{fields}{summary} for @_;
			}
	);
	if (defined $args{from} and exists $actions{ $args{from} }) {
		$actions{ $args{from} }->(@$issuelist);
	}
}

sub summary {
	my $wt_arr = shift;
	
	my %times;
	my $cumulative_time = 0;
	for my $wt (@$wt_arr) {
		my $dt = time_spent($wt->{start_time}, $wt->{end_time});
		$times{ $wt->{project} } += $dt;
		$cumulative_time += $dt;
	}

	my $summary_lines = join "", map {
			sprintf("% .2f\t%s\t%s\n", ($times{$_}/3600), $_, (exists $state->{issues}{$_} ? $state->{issues}{$_} : ""))
		} 
		sort { 
			$times{$b} <=> $times{$a} 
		} 
		keys %times;
	
	return $summary_lines . "------\n" . sprintf "%.2f", $cumulative_time/3600;
}

sub list_remote {
	my %args = @_;
	my $i = 1;
	my @remote = @{$state->{remote}};
	for my $csira (@remote) {
		print print_wtline(jira_json_to_wtline($csira), $i++);
	}
	if (@remote) {
		say "";
		say summary([ map {jira_json_to_wtline($_)} @remote ]);
	}
	else {
		say $args{on_error};
		$ret = 1;
	}
}

sub print_unlogged {
	if (defined $state->{start_mark}) {
		my $today = parse_date(undef);
		my $saved = $state->{start_mark}{d};
		if ($today->{Y} == $saved->{Y} and
			$today->{M} == $saved->{M} and
			$today->{D} == $saved->{D} ) {

			my $interval = -1 * time_spent(parse_time(undef), $state->{start_mark}{t}, noabs => 1);
			if ($interval < 0) {
				say "End of last local wt entry is in the future";
			}
			else {
				my ($h, $m, $s);
				$h = int($interval / 3600); $interval -= $h * 3600;
				$m = int($interval /   60); $interval -= $m *   60;
				$s = int($interval);
				$interval = join ':', $h, pad($m), pad($s);
				my $on_project = defined $state->{current_project} ?
									" on issue $state->{current_project}" :
									"";
				my $project_summary = defined $state->{current_project} && exists $state->{issues}->{ $state->{current_project} } ?
									"\t".$state->{issues}->{ $state->{current_project} } :
									"";
				my $comment = defined $state->{current_comment} && defined $state->{current_project} ?
									"\t($state->{current_comment})" :
									"";
				say "Unlogged work: ", $interval, $on_project, $project_summary, $comment;
			}
		}
	}
}

sub _handle_jira_error {
	my $response = shift;

	warn "JIRA responded with ".$response->status_line."\n";
	if ($response->code() == 401) {
		forget_pw();
	}
	else {
		my $error = decode_json $response->decoded_content;
		say STDERR join "\n",
			@{$error->{errorMessages}}
			if exists $error->{errorMessages} and ref $error->{errorMessages} eq 'ARRAY' and @{$error->{errorMessages}};
		say STDERR join "\n",
			map { $_.": ".$error->{errors}->{$_} }
			keys %{$error->{errors}}
			if exists $error->{errors} and ref $error->{errors} eq 'HASH';
	}
	$ret = 1;
}

###############

sub _print_date {
	join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H}, 
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;
	
	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});
	
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});
		
		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}
	
	return 0;
}

# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^\d\d?$/) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^(\d\d?)-(\d\d?)$/) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^(\d{4})-(\d\d?)-(\d\d?)$/) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}

		unless (defined $date) {
			die "Invalid date specifier, must be one of YYYY-MM-DD or MM-DD or DD\n";
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
# +HH:MM or +HH.H or +MMm relative intervals are also parsed here
sub parse_time {
	my $dstr = shift;

	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};

	my $is_interval = 0;
	if (defined $dstr and $dstr ne '') {
		if (index($dstr, '+') == 0) {
			substr($dstr, 0, 1, '');
			$is_interval = 1;
		}

		if ($is_interval and $dstr =~ /^(\d\d?)\.(\d+)$/) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^(\d+)m$/) {
			my $m = 0+$1;
			$time->{H} = int($m / 60);
			$time->{M} = $m % 60;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^(?:[01]?\d|2[0-3])$/) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^([01]?\d|2[0-3]):([0-5]?\d)$/) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^([01]?\d|2[0-3]):([0-5]?\d):([0-5]?\d)/) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
		unless (defined $time) {
			if ($is_interval) {
				die "Invalid interval spec '$dstr', must be one of +HH:MM:SS, +HH:MM, +HH, +MMm\n";
			}
			else {
				die "Invalid time spec '$dstr', must be one of HH:MM:SS, HH:MM, HH\n";
			}
		}
	}
	return $time;
}

sub _trunc {
	my ($text, $len) = @_;
	my $shortened = $len - 3;
	length $text > $shortened ? substr($text, 0, $shortened).'...' : $text;
}

sub pad {
	($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	
	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub _yesterday {
	my $dt = DateTime->now()->subtract( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub increment_time {
		my ($start, $increment) = @_;
		
		my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
		$t += $increment;
		$t = 86400 if $t > 86400; # FIXME
		my $h = int($t / 3600);
		my $m = int($t / 60) % 60;
		my $s = $t % 60;
		return { H => $h, M => $m, S => $s };
}

sub get_pw {
	my $pw;
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$pw = $keyring->get_password($username, "wt_client");
		if(!$pw) {
			$pw = read_pw_from_console();
			$keyring->set_password($username, $pw, "wt_client");
		}
	}
	else {
		$pw = read_pw_from_console();
	}
	return $pw;
}

sub forget_pw {
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$keyring->clear_password($username, "wt_client");
	}
}

sub read_pw_from_console {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
