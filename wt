#!/usr/bin/perl

=pod

=head1 NAME

wt - command line work log client

=head1 SYNOPSIS

Available subcommands:

    wt [add] [-d DATE|-y] [-c] [-f] [-a ACTIVITY] INTERVAL ISSUE COMMENT
    wt commit
    wt start [-f] [-c] [ISSUE] [COMMENT]
    wt report [-u USER] [RELATIVE-DATESPEC | START [END] [ISSUE]]
    wt rm [-r] INDEX|all
    wt issues [-a] [-s|-j] [-m NUM] STRING
    wt alias [ALIAS [COMMAND ...]]
    wt undo
    wt
    wt help [SUBCOMMAND]


=head1 DESCRIPTION

B<wt> can be used to track, log, and query working time with a convenient
command line interface.
Working time entries (discrete intervals with a starting and ending time)
are first collected in a local database, then committed to a JIRA instance.
Work log entries previously committed, as well as JIRA issue names and
descriptions, can be queried.

=head1 SUBCOMMANDS

=head2 ADD

    wt [add] [-d DATE|-y] [-c] [-f] [-a ACTIVITY] INTERVAL ISSUE COMMENT

Adds an entry to the local list of wt entries.

=head3 There are three mandatory arguments:

=over

=item Interval

Starting and ending time in B<HH:MM:SS> format, separated by a dash.

	[HH[:MM[:SS]]]-[HH[:MM[:SS]]]

If seconds are omitted, B<HH:MM:00> is assumed (whole minutes).
If minutes are omitted, B<HH:00:00> is assumed (whole hours).

If the starting time is omitted altogether, 
the saved start mark is used instead, if available.
It is an error to omit the start if no start mark is available.

If the ending time is omitted altogether, the current time is assumed.

The ending time is also saved for the start mark of the next
C<wt add> command. Thus, the interval argument may consist of 
just a single dash in certain cases, meaning 
"from the end of the last entry till now".

Alternatively, a relative interval may be specified with a C<+> (plus sign)
and a time specifier (B<HH:MM:SS>). Minutes and seconds may be omitted.
Fractional hours may also be specified, and a C<h> suffix may be added.
A C<m> suffix means minutes instead.

	+HH[:MM[:SS]]
	+HH.H[h]
	+MMm

Starting time is taken from the start mark. The command fails if there
is no start mark available.

=item Issue

Project or issue identifier, in B<PROJECT-NUMBER> format.
A single dash means to use the current project, if one is available.

=item Comment

Arbitrary text (can contain spaces etc. if quoted) to describe
the task/bugfix etc.
A single dash means to repeat the comment for the last entry (or the
comment saved with C<wt start>), if one is available.

=back

=head3 Options to the B<add> subcommand

=over

=item C<-a> Activity type

JIRA requires an activity type for each worklog entry. This can be
overridden with the C<-a> or C<--activity> switch.
The default activity type is "Dev".

=item C<-d> Set date

By default, the date for the entry is the current date. This can be overridden
by the C<-d> or C<--date> switch, which requires a date string in YYYY-MM-DD format. 
If the year or month is omitted, the current year or month is substituted.

=item C<-y> Yesterday

The C<-y> or C<--yesterday> switch sets the date to yesterday.

=item C<-c> Autocommit

By default, the C<add> subcommand only adds the entry to the local list, 
which must be committed with C<wt commit> separately.

This switch causes the entry to be committed immediately.

=item C<-f> Force

By default, a new entry that overlaps with any previous (local) entry is
rejected. This switch can be used to disable this check
(JIRA doesn't seem to care anyway).

=back

=head3 Lunch and breaks

Specifying C<lunch> or C<break> as the issue name will cause the following:

=over

=item The project name will be substituted from the "lunch-project" key in 
wt.conf. If that key doesn't exist, or the value is empty, 
lunch breaks will not be committed, they will be silently dropped instead.

=item The comment becomes optional, if omitted, "lunch" will be substituted.

=item The activity type will be set to "Break" unless explicitly overridden.

=back

The C<add> keyword may be omitted.

=head2 COMMIT

    wt commit
    wt ci

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt start [-f|--force] [-c|--change] [ISSUE] [COMMENT]
	wt s ...

Saves a timestamp with the current time. In effect, this command means
"I'm starting work now". An optional project (issue) name can be specified,
it will be saved as the current project.

The C<--change> or C<-c> option only changes the current issue, but does not
reset the timestamp.

If there is already a timestamp for the current date (in other words, you
have already used C<wt start> today), the command will not overwrite it
so as to prevent accidental clobbering of unlogged time. The C<-f> or
C<--force> switch can be used in this case to enforce saving the timestamp.

C<-f> and C<-c> are mutually exclusive, using them together is an error.

=head2 REPORT

    wt report [-u|--user USER]
    wt report [today | yesterday | week [DATE|last] | month [DATE|last]]
    wt report START [END] [ISSUE]
    wt r ...

Queries worklog entries from JIRA.
If this subcommand is called with two date arguments, worklog entries between the two date
are queried from JIRA. Dates must be specified as YYYY-MM-DD.
If the year or month is omitted, the current year or month is substituted.
C<today> can be used to mean the current date.
C<yesterday> can also be used with the expected meaning.

The end date may be omitted altogether, in which case the current date is assumed.

An optional third argument can be used to filter for project name.

Alternatively, certain magic relative date specifiers can be used in place
of an explicit date string in the first argument.

If the first argument is C<month>, worklog entries between
the start and end of the current month are queried. In this mode the
reported sum of logged hours is amended with a projection for the remainder
of the month, assuming that the user will log 8 hours for the remaining
working days (Monday to Friday).

An optional second argument after C<month> in the format of YYYY-MM or MM
causes worklogs from the specified month to be queried instead of the current month.
As a special case, this second argument can be C<last>, which queries
worklogs from the month preceding the current month.

If the first argument is C<week>, the effect is similar to that of C<month>,
expect worklogs between the start and end of the current week are queried.
An optional second argument can be given to C<week> too, but note that it
will be parsed as a regular [[YYYY]-MM]-DD date string, so a single number
will be interpreted as the day in the current month, and this will query
worklogs from the week that contain the specified day. As a special case,
this second argument can be C<last>, which queries worklogs from last week.

If C<wt report> is called without any arguments, it prints the
results of the last query (but doesn't send a new query to JIRA).

By default, C<wt report> queries your own worklogs.
The C<-u> or C<--user> switch can be used to query someone else's worklogs.
This will only work if you have the appropriate rights in JIRA
(the target user is in your team).

=head2 ISSUES

    wt issues [-a] [-s|-j] [-m NUM] [STRING]
    wt : ...

Query issues matching STRING from JIRA and print the resulting list.

Each entry contains the issue number, status, assignee and summary.

The list is sorted by date, latest is on the bottom.

If STRING looks like a JIRA issue (e.g. CG-54), it is assumed to be an issue number,
and the resulting list will contain that one issue (at most).
Otherwise, it is assumed to be a project number, and all issues under that project
are returned (if the project exists).

The -s or --summary switch can be used to search in the issue summaries instead.
In this case all issues are reported whose summaries match STRING.

Alternatively, the -j or --jql switch can be used to pass a raw JQL query string to JIRA.
The query string is not validated, just passed as is.

The -a or --assigned switch can be used to restrict the search to those issues 
that are assigned to the current user.

The -m or --max switch can be used to override the maximum number of issues reported, 
by default 100.

=head2 RM

    wt rm [-r] INDEX|all

Without the -r or --remote switch, this subcommand deletes one local wt entry.
The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

With the -r or --remote switch, this subcommand does something completely
different: it removes an already committed entry from JIRA.

In this case the INDEX argument is understood as the index of the entry
in the list of B<remote> entries, as reported by the last C<wt query> command.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.

=head2 ALIAS

    wt alias [ALIAS [COMMAND ...]]

This subcommand can be used to assign shortcuts to frequently used commands.

If called as e.g. C<wt alias foo add - ISSUE-1 foo>, then from that point
C<wt foo> will be understood as an alias for C<wt add - ISSUE-1 foo>.

Aliases are not expanded recursively, so only the default subcommands are
allowed as the aliased command. However, any string is accepted as an alias,
so even the default subcommands can be redefined.

If called with just an alias but without a definition, that alias is deleted.

If called without any parameters, the list of all defined aliases is printed.

=head2 UNDO

    wt undo

Undoes the effect of the last C<wt add> C<wt rm>, or C<wt start> command. 

This subcommand only touches (or more precisely, restores) the local
wt entry list, so entries already committed are not affected.
In other words, C<wt commit> cannot be undone.

There is only one level of undo.

=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=head1 EXAMPLES

A typical session (working day) begins with issuing the

	wt start

command, optionally with a JIRA issue identifier, to signify that you're
starting work for the day.

The simplest way to log time is right away when you're finished with a work unit
(bugfix, feature etc.):

	wt add - - implemented foo in module bar

This command means in essence I<I've worked on the current issue, from the
end of the last entry till now>.

Work can be continued to be logged in this way until the end of the day,
when you finally commit the day's work to JIRA:

	wt commit

This is not mandatory, however, you can also opt to record your work log
entries in one go at the end of the day, specifying explicit intervals
and issue names:

	wt add 9-12:30 BAR-42 implemented foo in module bar

or even

	wt +50m BAR-42 foo

if you don't care about exact starting and ending times, 
just the amount of time.

You can use

	wt : BAR

to search for issues in project BAR.

=head1 FILES

This program relies on two files called F<wt.conf> and F<wt.state>,
used to store user preferences and persistent state, respectively.

These files are expected to be in a directory called F<.wt> under the user's
home directory.

F<wt.conf>, the configuration file should be edited by the user before
attempting to use the program. It must be a valid JSON file.
The JSON object in it must have at least the following keys:

=over

=item jira_base_url

The base URL of the JIRA instance to which the worklog entries are to be
sent.

=item user_name

A valid JIRA user name, to be used for authentication.

=back

The following optional keys are also recognized:

=over

=item worklog_url

Override the standard REST API endpoint used by JIRA to submit/query
worklog entries

=item search_url

Override the standard REST API endpoint used by JIRA to search issues

=item lunch_project

Specify a JIRA issue for the C<wt add - lunch> feature

=item autocommit

Turns on autocommit mode: C<commit> is called after each invocation of 
<wt add>. Boolean key.

=item no_overlap_check

Disables checking for overlapping time intervals in C<wt add>. Boolean key.

=item holidays

An array of dates of fixed holidays that affect estimation of remaining 
working time for C<wt report month>.
Dates must be either in YYYY-MM-DD format (for non-fixed holidays like Easter
or government-issued special holidays that only occur in a specific year),
or in MM-DD format (for fixed holidays that apply to every year).

=item workdays

An array of dates that should count as workdays (despite falling on Saturday or Sunday).
This also affects estimation of remaining working time.
Dates must be in YYYY-MM-DD or MM-DD format (like above).

=back


Example:

	{
			"jira_base_url": "https://my.awesome.company.com/jira",
			"worklog_url": "/rest/tempo-timesheets/3/worklogs/",
			"search_url": "/rest/api/2/search",
			"user_name": "homer.simpson",
			"lunch_project": "CMPS-19",
			"autocommit": true,
			"holidays": ["01-01", "03-14", "03-15", "03-28", "05-01", "05-16", "08-20", "10-23", "10-31", "11-01", "12-24", "12-25", "12-26"],
			"workdays": ["03-05", "10-15"]
	}

F<wt.state>, the file to store persistent state between consequent runs
of the program, is modified by most subcommands (the exceptions are C<wt>
without arguments and C<wt report> without arguments). It is also a JSON
file, however, it is not intended to be directly edited by the user.

=head1 SAVING JIRA PASSWORD

The C<commit>, C<issues>, C<rm --remote> and C<report> subcommand have to connect to 
the JIRA instance specified in the config file. This requires authentication,
in the form of an user name and password. The user name is also specified
in the config file, however, the password is not.

On systems that have a keyring (more precisely, any working keyring 
implementation supported by the Passwd::Keyring::Auto module, which must
also be installed if keyring support is desired), the password is asked only once, then saved into the
keyring safely.

On systems without keyring support the JIRA password is asked before every
command that needs JIRA access.

Storing the password in plaintext is not supported (nor is it recommended).

=cut

use strict;
use warnings;
no if ($] >= 5.018), 'warnings' => 'experimental';
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;
use DateTime;
use Getopt::Long;
use Encode::Locale;
use Encode;
use Carp;
use Storable qw/dclone/;

# keyring support is optional, will be enabled only
# if the module is installed
my $have_keyring;
BEGIN {
	$have_keyring = eval {
		require Passwd::Keyring::Auto;
		Passwd::Keyring::Auto->import();
		1;
	};
}

# load config and state
my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);
my $ret = 0;

# precalculate workday and holiday hashes
my %holidays = validate_config_date_list($config, 'holidays');
my %workdays = validate_config_date_list($config, 'workdays');

# take care of encoding for output...
binmode STDOUT, ":encoding(UTF-8)";

# and for input as well
@ARGV = map { decode(locale => $_, 1) } @ARGV;

# get subcommand
my $action = shift @ARGV;

# take aliases into account
if (defined $action and exists $state->{aliases}{$action}) {
	my @cmds = @{$state->{aliases}{$action}};
	$action = shift @cmds;
	unshift @ARGV, @cmds;
}

# jump table for subcommands
for ($action) {
	when (undef)           { list_local(); }
	when ([qw/issues :/])  { get_issues(); }
	when ([qw/alias al/ ]) { set_alias();  }
	when ([qw/start  s/ ]) { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/undo u/ ])   { undo();       }
	when ([qw/help h/])    { help();       }
	when ([qw/add a/])     { add();        }
	when ("rm")            { rm();         }
	when (/^[\-\d\+]/)     { unshift @ARGV, $action; add(); }
	default                { help();       }
}

exit($ret);

###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/alias al/ ]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ALIAS"});  }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"}); }
		when ([qw/issues :/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ISSUES"}); }
		when ([qw/report r/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/undo u/ ])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/UNDO" });  }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/add a/])     { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ADD"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		print print_wtline($wt, $i++);
	}
	if (@{$state->{local}}) {
		say "";
		say summary($state->{local});
	}
	else {
		say "No local wt records.";
		$ret = 1;
	}

	print_unlogged();
	return;
}

sub set_alias {
	my $alias = shift @ARGV;

	if (defined $alias) {
		if (@ARGV) {
			$state->{aliases}{$alias} = [@ARGV];
		}
		else {
			delete $state->{aliases}{$alias};
		}
		save_state($state_fn, $state);
	}
	else {
		if (keys %{$state->{aliases}}) {
			while (my ($al, $def) = each %{$state->{aliases}}) {
				say $al, ":\t@$def";
			}
		}
		else {
			say "No defined aliases.";
			$ret = 1;
		}
	}
	return;
}

sub undo {
	$state->{local}      = dclone $state->{saved_local}      if exists $state->{saved_local};
	$state->{start_mark} = dclone $state->{saved_start_mark} if exists $state->{saved_start_mark};

	$state->{current_project} = $state->{saved_current_project} if exists $state->{saved_current_project};
	$state->{current_comment} = $state->{saved_current_comment} if exists $state->{saved_current_comment};

	save_state($state_fn, $state);
	list_local();
	return;
}

sub rm {
	my $remote = 0;
	GetOptions(
		'remote!'  => \$remote,
	) or help('rm');
	
	my $idx = shift @ARGV;
	if ($remote) {
		die "Error: specify the index of remote wt record to be deleted\n" unless $idx;
		die "Error: no remote wt records to delete\n" unless scalar @{$state->{remote}};

		my $pw = get_pw();

		if ($idx eq "all") {
			_rm_one_remote($_, $pw) for 0..$#{$state->{remote}};
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{remote}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{remote}};
			_rm_one_remote($idx-1, $pw);
		}
		# delete remote entries locally that were successfully deleted remotely
		$state->{remote} = [ grep { not exists $_->{deleted} } @{$state->{remote}} ];
		save_state($state_fn, $state);
		list_remote(on_error => "No remote worklog records.");
 	}
	else {
		die "Error: specify the index of local wt record to be deleted\n" unless $idx;
		die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};

		if ($idx eq "all") {
			save_local_state();
			$state->{local} = [];
			say "All local wt records deleted!";
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{local}};
			# at this point we should have a valid index to delete
			save_local_state();

			splice @{$state->{local}}, $idx-1, 1;
			
			# update start mark to end of last entry
			if (@{$state->{local}}) {
				$state->{current_project} = $state->{local}[-1]{project};
				$state->{start_mark} = { t => $state->{local}[-1]{end_time}, d => $state->{local}[-1]{date} };
			}
			# or try to restore explicit 'wt start' mark
			elsif (defined $state->{explicit_start_mark}) {
				$state->{start_mark} = dclone $state->{explicit_start_mark};
			}
		}
		save_state($state_fn, $state); 
		list_local();
	}
	return;
}

sub set_mark {
	my $change = 0;
	my $force  = 0;
	GetOptions(
		'change!' => \$change,
		'force!'  => \$force,
	) or help('start');

	die "Options -c and -f are mutually exclusive, make up your mind\n" if $force and $change;

	save_local_state();

	my $is_today = exists($state->{start_mark}) && is_today($state->{start_mark}{d});
	die "There is already a timestamp for today, use --force to overwrite it\n" if not $change and not $force and $is_today;

	if ($force or not ($change or $is_today)) {
		$state->{start_mark} = { t => parse_time(undef), d => parse_date(undef) };
		$state->{explicit_start_mark} = { t => parse_time(undef), d => parse_date(undef) };
	}

	my $project_str = shift @ARGV;
	if (defined $project_str) {
		$state->{current_project} = uc $project_str;
	}
	elsif ($change) {
		$project_str //= "";
		die "Error: project name required for wt start --change\n";
	}

	$state->{current_comment} = "@ARGV" if @ARGV;

	if ($change) {
		print_unlogged();
	}
	else {
		say "Started work", _current_project();
	}

	save_state($state_fn, $state); 
	return;
}

sub commit {
	my $pw = get_pw();
	my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};

	for my $wtline (@{$state->{local}}) {
		if (not $wtline->{no_commit}) {
			my $response = connect_to_jira(
				url     => $worklog_url,
				content => wtline_to_jira_json($wtline),
				pw      => $pw,
			);

			if ( $response->is_success() ) {
				# mark locally stored wt line if commit was successful
				$wtline->{committed} = 1;
			}
			else {
				_handle_jira_error($response);
			}

		}
	}
	# delete wt lines that were successfully committed and those that 
	# we don't need to commit
	$state->{local} = [ grep { not exists $_->{committed} and not $_->{no_commit} } @{$state->{local}} ];

	save_state($state_fn, $state);
	return;
}

sub query {
	my $target_user;
	GetOptions(
		'user=s' => \$target_user,
	) or help('report');

	my ($start_date_str, $end_date_str, $project) = @ARGV;

	if (defined $start_date_str) {
		my ($start_date, $end_date, $report_month_mode);

		if ($start_date_str eq 'month') {
			$report_month_mode = 'current';
			if (defined $end_date_str) {
				if ($end_date_str ne 'last') {
					$end_date_str .= '-1'; # kludge to add fake day part to YYYY-MM input to be able to use parse_date
				}
				$report_month_mode = 'historic';
			}
			($start_date, $end_date) = _get_month_start_end($end_date_str);
		}
		elsif ($start_date_str eq 'week') {
			$report_month_mode = 'current_week';
			if (defined $end_date_str) {
				$report_month_mode = 'historic';
			}
			($start_date, $end_date) = _get_week_start_end($end_date_str);
		}
		elsif ($start_date_str eq 'yesterday') {
			if (defined $end_date_str and not defined $project) {
				$project = $end_date_str;
			}
			$end_date = $start_date = _yesterday();
			$report_month_mode = 'custom_interval';
		}
		else {
			$start_date_str = undef if $start_date_str eq 'today';
			$start_date = parse_date($start_date_str);
			help('report') unless defined $start_date;

			$end_date = parse_date($end_date_str);
			$report_month_mode = 'custom_interval';
		}

		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date));
		$query_hash{projectKey} = $project if defined $project;
		if (defined $target_user) {
			# XXX :( for some reason querying $target_user doesn't work directly, I have to query for all team members then filter
			$query_hash{teamId} = $config->{teamId} // 7; # XXX hardcoded id :(
		} else {
			$query_hash{username} = $config->{user_name};
		}
		my $query_string = uri_escape_hash(%query_hash);

		my $response = connect_to_jira(
			http_action => 'GET',
			url         => $config->{jira_base_url}.$config->{worklog_url}."?".$query_string,
		);

		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;

			update_saved_issue_summaries($state->{remote}, from => 'remote');

			$state->{cached_query_month_mode} = $report_month_mode;
			list_remote(
				on_error     => "No worklog records in the specified date range.",
				report_month => $report_month_mode,
				start_date   => $start_date,
				end_date     => $end_date,
				filter_user  => $target_user);

			save_state($state_fn, $state);
		}
		else {
			_handle_jira_error($response);
		}

	}
	else {
		# print last saved query, don't actually ask jira
		list_remote(on_error => "There is no saved query.", report_month => 'cached');
	} 
	return;

}

sub get_issues {
	my $assigned_to_me = 0;
	my $summary = 0;
	my $max = 100;
	my $raw_jql;
	GetOptions(
		'assigned!' => \$assigned_to_me,
		'summary!'  => \$summary,
		'max=i'     => \$max,
		'jql=s'     => \$raw_jql,
	) or help('issues');

	my $filter = shift @ARGV;
	my @jql;
	if (defined $filter) {
		if ($raw_jql) {
			push @jql, $filter;
		}
		elsif ($summary) {
			push @jql, "summary ~ $filter";
		}
		elsif ($filter =~ /\w+-\d+/) {
			push @jql, "issue = $filter";
		}
		else {
			push @jql, "project = $filter";
		}
	}
	if ($assigned_to_me) {
		push @jql, "assignee = " . $config->{user_name};
	}
	my $jql = join " and ", @jql;
	$jql .= " order by createddate desc" if $jql;

	my $response = connect_to_jira(
		url     => $config->{jira_base_url}.$config->{search_url},
		content => encode_json({
			"jql" => $jql,
			"startAt" => 0,
			"maxResults" => $max,
			"fields" => [
				"summary",
				"status",
				"assignee"
			]
		})
	);

	if ( $response->is_success() ) {
		my $raw_data = decode_json $response->decoded_content;
		say for reverse map { 
				sprintf "%-12s%-16s%-16s%s", 
					$_->{key}, 
					_trunc($_->{fields}{status}{name}, 15), 
					$_->{fields}{assignee}{name} // "-", 
					$_->{fields}{summary}
				} 
			@{$raw_data->{issues}};

		update_saved_issue_summaries($raw_data->{issues}, from => 'issuelist');
		save_state($state_fn, $state);
	}
	else {
		_handle_jira_error($response);
	}
	return;

}

sub add {
	help("add") unless defined $ARGV[0];

	# get current date as default
	my $date = parse_date(undef);

	# defaults
	my $autocommit = 0;
	my $no_overlap_check = 0;
	my $activity = undef;

	# need to check if first arg is interval spec (single dash or dash-number)
	# before calling GetOptions
	Getopt::Long::Configure(qw/no_ignore_case pass_through/);
	unless ($ARGV[0] =~ /^\-$|^\-\d|^\+/) {
		GetOptions(
			'date=s'     => sub { $date = parse_date($_[1]); },
			'yesterday!' => sub { $date = _yesterday(); },
			'commit!'    => \$autocommit,
			'activity=s' => \$activity,
			'force!'     => \$no_overlap_check,
		);
		help('add') if @ARGV and $ARGV[0] =~ /-[^0-9]/;
	}

	# first argument: from-to time or relative interval
	my $interval = shift @ARGV;
	die "Error: missing time or interval spec\n" unless defined $interval;
	my ($start_time, $end_time);

	# relative interval
	if (index($interval, '+') == 0) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark}{t};
		}
		else {
			die "Error: no saved starting time available, you must specify the interval explicitly\n";
		}
		my $t = parse_time($interval);

		$end_time = increment_time($start_time, time_spent({H=>0, M=>0, S=>0}, $t));
	}
	# absolute interval
	else {
		my ($s, $e) = split '-', $interval;

		# If from is not specified, try to use saved start mark.
		# If there is no start mark either, give up.
		if (not defined $s or $s eq '') {
			if (defined $state->{start_mark}) {
				$start_time = $state->{start_mark}{t};
			}
			else {
				die "Error: no saved starting time available, you must specify it explicitly\n";
			}
		}
		else {
			$start_time = parse_time($s);
		}
		# end time falls back to current time if not specified
		$end_time = parse_time($e);
	}

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = shift @ARGV;
	my $project;
	my $project_is_lunch = 0;
	my $no_commit = 0;
	if (defined $project_str) {
		if ($project_str eq "-") {
			# use saved current project
			$project = $state->{current_project};
			die "Error: no current project available\n" unless defined $project;
		}
		elsif ($project_str eq "lunch" or $project_str eq "break") {
			# special hack: shortcut for lunch
			$project = $config->{lunch_project};
			$project_is_lunch = 1;
			$no_commit = 1 if $project eq ''; # don't commit breaks if lunch/break project is empty
		}
		else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" unless defined $project;
		}
	}
	else {
		die "Error: project name is mandatory\n";
	}
	$project = uc $project;

	# third argument: comment
	# rest of @ARGV is concatenated so that quotes are not needed
	my $comment = "@ARGV";
	# special hack: no comment is required for lunch or break
	$comment = $project_str if $comment eq '' and $project_is_lunch;
	die "Error: Comment is required\n" if $comment eq '';
	# use saved comment if one is available and explicitly requested
	$comment = $state->{current_comment} if $comment eq '-' and defined $state->{current_comment};
	# and save current comment for future use... in the end, when we can change state safely

	# activity may have been set by option
	# special hack: no comment is required for lunch
	$activity = "Break" if not defined $activity and $project_is_lunch;
	$activity //= 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
		no_commit  => $no_commit,
	};

	if (not ($no_overlap_check or $config->{no_overlap_check})
	and my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef) ."\n";
	}

	# do this as late as possible, when we're sure all input was correct
	save_local_state();

	push @{$state->{local}}, $wtline;
	_sort_local_wtlines();

	$state->{current_project} = $project unless $project_str eq 'lunch';
	$state->{current_comment} = $comment unless $project_is_lunch;
	$state->{start_mark} = { t => $end_time, d => $date };

	save_state($state_fn, $state);
	list_local();

	if ($autocommit or $config->{autocommit}) {
		commit();
	}
	return;
}

###############

sub _sort_local_wtlines {
	$state->{local} = [
		map {$_->[1]}
		sort { $a->[0] cmp $b->[0] }
		map { [(join "\t",
			_print_date($_->{date}),
			_print_time($_->{start_time}),
			_print_time($_->{end_time}) ), $_] }
		@{$state->{local}}
	];
}

sub _rm_one_remote {
	my $idx = shift;
	my $pw = shift;

	my $id = $state->{remote}[$idx]{id};

	my $response = connect_to_jira(
		http_action => 'DELETE',
		url     => $config->{jira_base_url}.$config->{worklog_url}.$id.'/',
		pw      => $pw,
	);

	if ( $response->is_success() ) {
		# mark locally stored remote entry if delete was successful
		$state->{remote}[$idx]->{deleted} = 1;
	}
	else {
		_handle_jira_error($response);
	}
	return;
}

sub save_local_state {
	$state->{saved_local}           = dclone($state->{local} // []);
	$state->{saved_start_mark}      = dclone $state->{start_mark} if defined $state->{start_mark};
	$state->{saved_current_project} = $state->{current_project};
	$state->{saved_current_comment} = $state->{current_comment};

	return;
}

###############

sub validate_config_date_list {
	my ($config, $key) = @_;

	my $this_year = 1900 + (localtime)[5];

	my %result;
	if (exists $config->{$key} and ref $config->{$key} eq 'ARRAY') {
		for my $dstr (@{$config->{$key}}) {
			if (my ($year, $month_day) = ($dstr =~ /^ (\d{4}) - (\d{1,2} - \d{1,2}) $/x)) {
				if ($year == $this_year) {
					$result{$month_day} = 1;
				}
			}
			elsif ($dstr =~ /^ \d{1,2} - \d{1,2} $/x) {
				$result{$dstr} = 1;
			}
			else {
				die "Incorrect date specification '$dstr' in $key list in config\n";
			}
		}
	}
	return %result;
}

sub _load_json {
	my ($fn) = @_;
	local $/ = undef;
	open(my $FH, "<", $fn) or return; # undef
	my $json = <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
	return;
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	die "Missing key from config file: jira_base_url\n" unless defined $config->{jira_base_url};
	die "Missing key from config file: user_name\n" unless defined $config->{user_name};
	$config->{worklog_url} //= "/rest/tempo-timesheets/3/worklogs/";
	$config->{search_url}  //= "/rest/api/2/search";
	$config->{lunch_project} //= '';

	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	_save_json($_[0], $_[1], "state");
	return;
}

###############

sub connect_to_jira {
	my %args = (
		http_action => 'POST',
		url         => undef,
		content     => '',
		pw          => undef,
		@_
	);

	my $pw = $args{pw} // get_pw();

	my $req = HTTP::Request->new($args{http_action}, $args{url});
	$req->header('Content-Type' => 'application/json;charset=UTF-8') if $args{http_action} eq 'POST';
	$req->authorization_basic($config->{user_name}, $pw);
	$req->content($args{content});

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);
	return $response;
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});
	
	my $ojject = {
		issue => {
			key => uc $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		billedSeconds => 0,
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => { 
			name => $config->{user_name} 
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;
	
	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});

	my $jwlattr = $jira->{worklogAttributes};
	my $ai = 0;
	$jwlattr->[$_]{key} eq '_Activity_' and $ai = $_ and last for 0..$#$jwlattr;

	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jwlattr->[$ai]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';
	
	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

sub update_saved_issue_summaries {
	my $issuelist = shift;
	my %args = @_;

	my %actions = (
		remote => sub {
				$state->{issues}->{ $_->{issue}{key} } = $_->{issue}{summary} for @_;
			},
		issuelist => sub {
				$state->{issues}->{ $_->{key} } = $_->{fields}{summary} for @_;
			}
	);
	if (defined $args{from} and exists $actions{ $args{from} }) {
		$actions{ $args{from} }->(@$issuelist);
	}
	return;
}

sub summary {
	my ($wt_arr, %args) = @_;
	
	my %times;
	my $cumulative_time = 0;
	for my $wt (@$wt_arr) {
		my $dt = time_spent($wt->{start_time}, $wt->{end_time});
		$times{ $wt->{project} } += $dt;
		$cumulative_time += $dt;
	}

	my $summary_lines = join "", map {
			sprintf("% 6.2f\t%s\t%s\n", ($times{$_}/3600), $_, (exists $state->{issues}{$_} ? $state->{issues}{$_} : ""))
		} 
		sort { 
			$times{$b} <=> $times{$a} 
		} 
		keys %times;

	my $cumulative_hours = $cumulative_time/3600;
	my $res_str = $summary_lines . "------\n" . sprintf "% 6.2f", $cumulative_hours;

	my $estimate_month = $args{report_month} // '';
	my $cached_mode = $estimate_month eq 'cached';
	if ($cached_mode and defined $state->{cached_query_month_mode}) {
		$estimate_month = $state->{cached_query_month_mode};
	}

	my %summary_annotations = (
		'current' => sub {
			my $today = parse_date();
			my ($start_month, $end_month) = _get_month_start_end();
			my $required_till_now        = _estimate_required_workday_hours($start_month, $today);
			my $required_till_end_month  = _estimate_required_workday_hours($start_month, $end_month);
			my $estimated_till_end_month = $required_till_end_month - $required_till_now + $cumulative_hours;
			return sprintf "/%.2f required, % 6.2f/%.2f estimated at the end of the month",
							$required_till_now,
							$estimated_till_end_month,
							$required_till_end_month;
		},
		'current_week' => sub {
			my $today = parse_date();
			my ($start_week, $end_week)  = _get_week_start_end();
			my $required_till_now        = _estimate_required_workday_hours($start_week, $today);
			my $required_till_end_week   = _estimate_required_workday_hours($start_week, $end_week);
			my $estimated_till_end_week  = $required_till_end_week - $required_till_now + $cumulative_hours;
			return sprintf "/%.2f required, % 6.2f/%.2f estimated at the end of the week",
							$required_till_now,
							$estimated_till_end_week,
							$required_till_end_week;
		},
		'historic' => sub {
			my ($start_month, $end_month) = _get_month_start_end();
			my $required_till_end_month  = _estimate_required_workday_hours(
							$args{start_date} // $start_month,
							$args{end_date}  // $end_month);
			return sprintf "/%.2f required",
							$required_till_end_month;
		},
		'custom_interval' => sub {
			my $start_date = {Y => 2100, M => 1, D => 1};
			my $end_date   = {Y => 1900, M => 1, D => 1};
			for my $date (map { $_->{date} } @$wt_arr) {
				$start_date = $date if compare_dates($start_date, $date) > 0;
				$end_date   = $date if compare_dates($end_date,   $date) < 0;
			}
			my $required_in_interval = _estimate_required_workday_hours(
							$args{start_date} // $start_date,
							$args{end_date}  // $end_date);
			return sprintf "/%.2f required",
							$required_in_interval;
		},
	);
	$res_str .= $summary_annotations{$estimate_month}->() if exists $summary_annotations{$estimate_month};
	$res_str .= ' (cached query)' if $cached_mode;
	return $res_str;
}

sub sparkline {
	my ($wt_arr, $mode) = @_;
	my @l = (' ', map chr 0x2580+$_, 1..8); ##▁▂▃▄▅▆▇█
	my @w = qw/m t w T f s S/;
	my (@lines, @daily_sums);
	for my $wt (@$wt_arr) {
		my $d = $wt->{date}->{D};
		my $t = time_spent($wt->{start_time}, $wt->{end_time});
		$daily_sums[$d] += $t;
	}
	my ($start, $end);
	if ($mode eq 'current' or $mode eq 'historic') {
		($start, $end) = _get_month_start_end($wt_arr->[0]->{date});
	} elsif ($mode eq 'current_week') {
		($start, $end) = _get_week_start_end($wt_arr->[0]->{date});
	} else {
		return;
	}

	my $dow = DateTime->new(year => $start->{Y}, month => $start->{M}, day => $start->{D})->day_of_week();
	$dow--;
	$lines[1][0] = $lines[0][0] = chr 0x259e;
	$lines[$_][0] = ' ' for 2..4;
	for my $d ($start->{D} .. $end->{D}) {
		my $s = $daily_sums[$d] // 0;
		$s /= 3600;
		push @{$lines[0]}, $l[ $s <  8 ? 0 : $s - 8]; # overtime
		push @{$lines[1]}, $l[ $s >= 8 ? 8 : $s    ]; # core time
		push @{$lines[2]}, $w[$dow++]; $dow %= 7;     # day of week
		push @{$lines[3]}, int($d / 10);              # digits of date
		push @{$lines[4]}, $d % 10;
	}
	push @{$lines[0]}, chr 0x259a;
	push @{$lines[1]}, chr 0x259a;
	local $" = '';
	return join "\n", map "@$_", @lines;
}

sub list_remote {
	my %args = @_;
	my $i = 1;
	my @remote = @{$state->{remote}};
	@remote = grep { $_->{author}->{name} eq $args{filter_user} } @remote if defined $args{filter_user};
	for my $csira (@remote) {
		print print_wtline(jira_json_to_wtline($csira), $i++);
	}
	if (@remote) {
		my $wt_arr = [ map {jira_json_to_wtline($_)} @remote ];
		say sparkline($wt_arr, $args{report_month});
		say "";
		say summary($wt_arr, %args);
	}
	else {
		say $args{on_error};
		$ret = 1;
	}
	return;
}

sub print_unlogged {
	my $whence;
	if (@{ $state->{local} } and is_today($state->{local}->[-1]->{date})) {
		$whence = $state->{local}->[-1]->{end_time};
	}
	elsif (defined $state->{start_mark} and is_today($state->{start_mark}{d})) {
		$whence = $state->{start_mark}{t};
	}

	if (defined $whence) {
		my $interval = -1 * time_spent(parse_time(undef), $whence, noabs => 1);
		if ($interval < 0) {
			say "End of last local wt entry is in the future";
		}
		else {
			my ($h, $m, $s);
			$h = int($interval / 3600); $interval -= $h * 3600;
			$m = int($interval /   60); $interval -= $m *   60;
			$s = int($interval);
			$interval = join ':', $h, pad($m), pad($s);
			say "Unlogged work: ", $interval, _current_project();
		}
	}
	return;
}

sub _current_project {
	my $on_project = defined $state->{current_project} ?
						" on issue $state->{current_project}" :
						"";
	my $project_summary = defined $state->{current_project} && exists $state->{issues}->{ $state->{current_project} } ?
						"\t".$state->{issues}->{ $state->{current_project} } :
						"";
	my $comment = defined $state->{current_comment} && defined $state->{current_project} ?
						"\t($state->{current_comment})" :
						"";
	return join "", $on_project, $project_summary, $comment;
}

sub _handle_jira_error {
	my $response = shift;

	warn "JIRA responded with ".$response->status_line."\n";
	if ($response->code() == 401) {
		forget_pw();
	}
	elsif ($response->code() >= 500) {
		# likely not json but some java backtrace in HTML
		say STDERR $response->decoded_content;
	}
	else {
		my $error = decode_json $response->decoded_content;
		say STDERR join "\n",
			@{$error->{errorMessages}}
			if exists $error->{errorMessages} and ref $error->{errorMessages} eq 'ARRAY' and @{$error->{errorMessages}};
		say STDERR join "\n",
			map { $_.": ".$error->{errors}->{$_} }
			keys %{$error->{errors}}
			if exists $error->{errors} and ref $error->{errors} eq 'HASH';
	}
	$ret = 1;
	return;
}

###############

sub _print_date {
	return join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	return join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H}, 
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;
	
	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});
	
	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});
		
		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}
	
	return 0;
}

sub _get_week_start_end {
	my $date_str = shift;
	my $dt;
	if (defined $date_str and $date_str eq 'last') {
		$dt = DateTime->now(time_zone => "local");
		$dt->subtract( days => 7);
	}
	elsif (defined $date_str) {
		my $date;
		if (ref $date_str eq 'HASH') {
			$date = $date_str;
		} else {
			# assumed to be a regular [[YYYY]-MM]-DD date string
			$date = parse_date($date_str);
		}
		$dt = DateTime->new(year => $date->{Y}, month => $date->{M}, day => $date->{D});
	}
	else {
		$dt = DateTime->now(time_zone => "local");
	}
	my $dow = $dt->day_of_week();
	$dt->subtract( days => ( $dow + 6 ) % 7 ); # Monday of the week
	my $start = {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
	$dt->add( days => 6 ); # Sunday of the week
	my $end   = {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
	return $start, $end;
}

# get the first and last day of the current month (leap years accounted for)
sub _get_month_start_end {
	my $date_str = shift;
	my ($dt, $start);
	if (defined $date_str and $date_str eq 'last') {
		$dt = DateTime->now(time_zone => "local");
		$dt->subtract(months => 1);
		$start = { Y => $dt->year, M => $dt->month, D => 1 };
	} else {
		if (ref $date_str eq 'HASH') {
			$start = $date_str;
		} else {
			$start = parse_date($date_str);
		}
		$start->{D} = 1;
		$dt = DateTime->new(year => $start->{Y}, month => $start->{M}, day => 1);
	}

	my $last_day = DateTime->last_day_of_month(
		month => $dt->month,
		year  => $dt->year,
	)->day;

	my $end = { %$start, D => $last_day };

	return $start, $end;
}

sub _estimate_required_workday_hours {
	my ($start_date, $end_date) = @_;

	my $sum_so_far = 0;
	my $day = DateTime->new(year => $start_date->{Y}, month => $start_date->{M}, day => $start_date->{D});
	my $end_DT = DateTime->new(year => $end_date->{Y}, month => $end_date->{M}, day => $end_date->{D});

	while ($day <= $end_DT) {
		my $dow = $day->day_of_week();
		my $dstr = sprintf "%02d-%02d", $day->month(), $day->day();
		my $is_workday = 1;
		$is_workday = 0 if $dow == 6 or $dow == 7 or exists $holidays{$dstr};
		$is_workday = 1 if exists $workdays{$dstr};
		$sum_so_far += 8 if $is_workday;
		$day->add(days => 1);
	}

	return $sum_so_far;
}

sub is_today {
	my ($date) = @_;
	my $today = parse_date(undef);

	return (
		$today->{Y} == $date->{Y} &&
		$today->{M} == $date->{M} &&
		$today->{D} == $date->{D}
	);
}

sub compare_dates {
	$_[0]->{Y} <=> $_[1]->{Y}
				||
	$_[0]->{M} <=> $_[1]->{M}
				||
	$_[0]->{D} <=> $_[1]->{D}
};


# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};
	
	if (defined $dstr and $dstr) {
		if ($dstr =~ /^ \d\d? $/x) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^ (\d\d?) - (\d\d?) $/x) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^ (\d{4}) - (\d\d?) - (\d\d?) $/x) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}

		unless (defined $date) {
			die "Invalid date specifier, must be one of YYYY-MM-DD or MM-DD or DD\n";
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
# +HH:MM or +HH.H or +MMm relative intervals are also parsed here
sub parse_time {
	my $dstr = shift;

	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};

	my $is_interval = 0;
	if (defined $dstr and $dstr ne '') {
		if (index($dstr, '+') == 0) {
			substr($dstr, 0, 1, '');
			$is_interval = 1;
		}

		if ($is_interval and $dstr =~ /^ (\d\d?) \. (\d+) $/x) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^ (\d\d?) \.? (\d*) h $/x) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^ (\d+) m $/x) {
			my $m = 0+$1;
			$time->{H} = int($m / 60);
			$time->{M} = $m % 60;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^ (?: [0 1]? \d | 2 [0-3] ) $/x) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^ ( [0 1]? \d | 2 [0-3] ) : ( [0-5]? \d ) $/x) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^ ( [0 1]? \d | 2 [0-3] ) : ( [0-5]? \d ) : ( [0-5]? \d ) /x) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
		unless (defined $time) {
			if ($is_interval) {
				die "Invalid interval spec '$dstr', must be one of +HH:MM:SS, +HH:MM, +HH, +MMm\n";
			}
			else {
				die "Invalid time spec '$dstr', must be one of HH:MM:SS, HH:MM, HH\n";
			}
		}
	}
	return $time;
}

sub _trunc {
	my ($text, $len) = @_;
	my $shortened = $len - 3;
	return (length $text > $shortened) ? substr($text, 0, $shortened).'...' : $text;
}

sub pad {
	return ($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	
	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub _yesterday {
	my $dt = DateTime->now(time_zone => "local")->subtract( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub _tomorrow {
	my $dt = DateTime->now(time_zone => "local")->add( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub increment_time {
	my ($start, $increment) = @_;
	
	my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	$t += $increment;
	$t = 86400 if $t > 86400; # FIXME
	my $h = int($t / 3600);
	my $m = int($t / 60) % 60;
	my $s = $t % 60;
	return { H => $h, M => $m, S => $s };
}

sub get_pw {
	my $pw;
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$pw = $keyring->get_password($username, "wt_client");
		if(!$pw) {
			$pw = read_pw_from_console();
			$keyring->set_password($username, $pw, "wt_client");
		}
	}
	else {
		$pw = read_pw_from_console();
	}
	return $pw;
}

sub forget_pw {
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$keyring->clear_password($username, "wt_client");
	}
	return;
}

sub read_pw_from_console {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
