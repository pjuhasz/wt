#!/usr/bin/perl

=pod

=head1 NAME

wt - command line work log client

=head1 SYNOPSIS

Available subcommands:

    wt <c|ci|commit> [-d DATE|-y] [-c] [-f] [-a ACTIVITY] [-t INTERVAL] [-i ISSUE] [-m COMMENT]
    wt <p|push>
    wt <start s> [-c] [-d DATE] [-t TIME] [-i ISSUE] [-a ACTIVITY] [-m COMMENT]
    wt report [month [DATE] | START [END] [ISSUE]]
    wt rm [-r] INDEX|all
    wt issues [-a] [-s|-j] [-m NUM] STRING
    wt alias [ALIAS [COMMAND ...]]
    wt
    wt help [SUBCOMMAND]


=head1 DESCRIPTION

B<wt> can be used to track, log, and query working time with a convenient
command line interface.
Working time entries (discrete intervals with a starting and ending time)
are first collected in a local database, then committed to a JIRA instance.
Work log entries previously committed, as well as JIRA issue names and
descriptions, can be queried.

=head1 SUBCOMMANDS

=head2 COMMIT

    wt <ci|commit> [-d DATE|-y] [-c] [-f] [-a ACTIVITY] [-t INTERVAL] [-i ISSUE] [-m COMMENT]

Adds an entry to the local list of wt entries.

=head3 There are no mandatory arguments

However, if not given here, ISSUE and COMMENT and a start time must be defined by the sart mark.

=over

=item Interval

Starting and ending time in B<HH:MM:SS> format, separated by a dash.

	[HH[:MM[:SS]]]-[HH[:MM[:SS]]]

If seconds are omitted, B<HH:MM:00> is assumed (whole minutes).
If minutes are omitted, B<HH:00:00> is assumed (whole hours).

If the starting time is omitted altogether,
the saved start mark is used instead, if available.
It is an error to omit the start if no start mark is available.

If the ending time is omitted altogether, the current time is assumed.

The ending time is also saved for the start mark of the next
C<wt commit> command. Thus, the interval argument may consist of
just a single dash in certain cases, meaning
"from the end of the last entry till now".

Alternatively, a relative interval may be specified with a C<+> (plus sign)
and a time specifier (B<HH:MM:SS>). Minutes and seconds may be omitted.
Fractional hours may also be specified. A C<m> suffix means minutes.

	+HH[:MM[:SS]]
	+HH.H
	+MMm

Starting time is taken from the start mark. The command fails if there
is no start mark available.

=item Issue

Project or issue identifier, in B<PROJECT-NUMBER> format.
A single dash means to use the current project, if one is available.

=item Comment

Arbitrary text (can contain spaces etc. if quoted) to describe
the task/bugfix etc.
A single dash means to repeat the comment for the last entry (or the
comment saved with C<wt start>), if one is available.

=back

=head3 Options to the B<commit> subcommand

=over

=item C<-a> Activity type

JIRA requires an activity type for each worklog entry. This can be
overridden with the C<-a> or C<--activity> switch.
The default activity type is "Dev".

=item C<-d> Set date

By default, the date for the entry is the current date. This can be overridden
by the C<-d> or C<--date> switch, which requires a date string in YYYY-MM-DD format.
If the year or month is omitted, the current year or month is substituted.

=item C<-y> Yesterday

The C<-y> or C<--yesterday> switch sets the date to yesterday.

=item C<-c> Autocommit

By default, the C<add> subcommand only adds the entry to the local list,
which must be committed with C<wt commit> separately.

This switch causes the entry to be committed immediately.

=item C<-f> Force

By default, a new entry that overlaps with any previous (local) entry is
rejected. This switch can be used to disable this check
(JIRA doesn't seem to care anyway).

=back

=head3 Lunch and breaks

Specifying "lunch" as the issue name will cause the following:

=over

=item The project name will be substituted from the "lunch-project" key in
wt.conf. If that key doesn't exist, the program terminates with an error.

=item The comment becomes optional, if omitted, "lunch" will be substituted.

=item The activity type will be set to "Break" unless explicitly overridden.

=back

=head2 PUSH

    wt <p|push>

Attempt to commit local wt entries to JIRA.
Successfully committed entries are deleted from the list.

=head2 START

	wt <s|start> [-c|--change] [-p|--preserve] [-d DATE] [-i ISSUE] [-m COMMENT] [-a ACTIVITY]

Saves a timestamp with the given date, or the current time if it is omitted. In effect, this command means
"I'm starting work". An optional project (issue) name can be specified, with a comment and activity.
it will be saved as the current project.

The C<--change> or C<-c> option only changes the current issue data, but does not
reset the timestamp.

If C<--preserve> or C<-p> is given, start mark data is preserved from the previous one.

=head2 REPORT

    wt report [month [DATE] | START [END] [ISSUE]]
    wt r ...

Queries worklog entries from JIRA.
If this subcommand is called with two date arguments, worklog entries between the two date
are queried from JIRA. Dates must be specified as YYYY-MM-DD.
If the year or month is omitted, the current year or month is substituted.
C<today> can be used to mean the current date.

The end date may be omitted altogether, in which case the current date is assumed.

An optional third argument can be used to filter for project name.

Alternatively, if the first argument is C<month>, worklog entries between
the start and end of the current month are queried. In this mode the
reported sum of logged hours is amended with a projection for the remainder
of the month, assuming that the user will log 8 hours for the remaining
working days (Monday to Friday).

An optional second argument after C<month> in the format of YYYY-MM or MM
causes worklogs from the specified month to be queried instead of the current month.

If C<wt report> is called without any arguments, it prints the
results of the last query (but doesn't send a new query to JIRA).

=head2 ISSUES

    wt issues [-a] [-s|-j] [-m NUM] [STRING]
    wt : ...

Query issues matching STRING from JIRA and print the resulting list.

Each entry contains the issue number, status, assignee and summary.

The list is sorted by date, latest is on the bottom.

If STRING looks like a JIRA issue (e.g. CG-54), it is assumed to be an issue number,
and the resulting list will contain that one issue (at most).
Otherwise, it is assumed to be a project number, and all issues under that project
are returned (if the project exists).

The -s or --summary switch can be used to search in the issue summaries instead.
In this case all issues are reported whose summaries match STRING.

Alternatively, the -j or --jql switch can be used to pass a raw JQL query string to JIRA.
The query string is not validated, just passed as is.

The -a or --assigned switch can be used to restrict the search to those issues
that are assigned to the current user.

The -m or --max switch can be used to override the maximum number of issues reported,
by default 100.

=head2 RM

    wt rm [-r] INDEX|all

Without the -r or --remote switch, this subcommand deletes one local wt entry.
The index number of the entry to be deleted is
the same as reported by "wt" without arguments.

Alternatively, if called as "wt rm all", all local entries are deleted.

With the -r or --remote switch, this subcommand does something completely
different: it removes an already committed entry from JIRA.

In this case the INDEX argument is understood as the index of the entry
in the list of B<remote> entries, as reported by the last C<wt query> command.

=head2 LIST

    wt

(wt command without arguments)
List local wt entries.

=head2 ALIAS

    wt alias [ALIAS [COMMAND ...]]

This subcommand can be used to assign shortcuts to frequently used commands.

If called as e.g. C<wt alias foo add - ISSUE-1 foo>, then from that point
C<wt foo> will be understood as an alias for C<wt add - ISSUE-1 foo>.

Aliases are not expanded recursively, so only the default subcommands are
allowed as the aliased command. However, any string is accepted as an alias,
so even the default subcommands can be redefined.

If called with just an alias but without a definition, that alias is deleted.

If called without any parameters, the list of all defined aliases is printed.

=head2 HELP

    wt help [SUBCOMMAND]

Prints available subcommands if called without arguments,
or detailed help for a subcommand.

=head1 EXAMPLES

A typical session (working day) begins with issuing the

	wt start

command, optionally with a JIRA issue identifier, to signify that you're
starting work for the day.

The simplest way to log time is right away when you're finished with a work unit
(bugfix, feature etc.):

	wt add - - implemented foo in module bar

This command means in essence I<I've worked on the current issue, from the
end of the last entry till now>.

Work can be continued to be logged in this way until the end of the day,
when you finally commit the day's work to JIRA:

	wt commit

This is not mandatory, however, you can also opt to record your work log
entries in one go at the end of the day, specifying explicit intervals
and issue names:

	wt add 9-12:30 BAR-42 implemented foo in module bar

or even

	wt +50m BAR-42 foo

if you don't care about exact starting and ending times,
just the amount of time.

You can use

	wt : BAR

to search for issues in project BAR.

=head1 FILES

This program relies on two files called F<wt.conf> and F<wt.state>,
used to store user preferences and persistent state, respectively.

These files are expected to be in a directory called F<.wt> under the user's
home directory.

F<wt.conf>, the configuration file should be edited by the user before
attempting to use the program. It must be a valid JSON file.
The JSON object in it must have at least the following keys:

=over

=item jira_base_url

The base URL of the JIRA instance to which the worklog entries are to be
sent.

=item user_name

A valid JIRA user name, to be used for authentication.

=back

The following optional keys are also recognized:

=over

=item worklog_url

Override the standard REST API endpoint used by JIRA to submit/query
worklog entries

=item search_url

Override the standard REST API endpoint used by JIRA to search issues

=item lunch_project

Specify a JIRA issue for the C<wt add - lunch> feature

=item autocommit

Turns on autocommit mode: C<commit> is called after each invocation of
<wt add>. Boolean key.

=item no_overlap_check

Disables checking for overlapping time intervals in C<wt add>. Boolean key.

=item holidays

An array of dates of fixed holidays that affect estimation of remaining
working time for C<wt report month>.
Dates must be in MM-DD format.

=item workdays

An array of dates that should count as workdays (despite falling on Saturday or Sunday).
This also affects estimation of remaining working time.
Dates must be in MM-DD format.

=back


Example:

	{
			"jira_base_url": "https://my.awesome.company.com/jira",
			"worklog_url": "/rest/tempo-timesheets/3/worklogs/",
			"search_url": "/rest/api/2/search",
			"user_name": "homer.simpson",
			"lunch_project": "CMPS-19",
			"autocommit": true,
			"holidays": ["01-01", "03-14", "03-15", "03-28", "05-01", "05-16", "08-20", "10-23", "10-31", "11-01", "12-24", "12-25", "12-26"],
			"workdays": ["03-05", "10-15"]
	}

F<wt.state>, the file to store persistent state between consequent runs
of the program, is modified by most subcommands (the exceptions are C<wt>
without arguments and C<wt report> without arguments). It is also a JSON
file, however, it is not intended to be directly edited by the user.

=head1 SAVING JIRA PASSWORD

The C<commit>, C<issues>, C<rm --remote> and C<report> subcommand have to connect to
the JIRA instance specified in the config file. This requires authentication,
in the form of an user name and password. The user name is also specified
in the config file, however, the password is not.

On systems that have a keyring (more precisely, any working keyring
implementation supported by the Passwd::Keyring::Auto module, which must
also be installed if keyring support is desired), the password is asked only once, then saved into the
keyring safely.

On systems without keyring support the JIRA password is asked before every
command that needs JIRA access.

Storing the password in plaintext is not supported (nor is it recommended).

=cut

use strict;
use warnings;
no warnings qw/experimental/;
use feature qw/say switch/;
use Pod::Usage;
use JSON qw/encode_json decode_json/;
use HTTP::Request;
use LWP::UserAgent;
use Term::ReadKey;
use File::Spec;
use Time::Local;
use Data::Dumper;
use URI::Escape;
use DateTime;
use Getopt::Long;
use Encode::Locale;
use Encode;
use Carp;

# keyring support is optional, will be enabled only
# if the module is installed
my $have_keyring;
BEGIN {
	$have_keyring = eval {
		require Passwd::Keyring::Auto;
		Passwd::Keyring::Auto->import();
		1;
	};
}

# load config and state
my $config_fn = File::Spec->catfile($ENV{HOME}, ".wt", "wt.conf");
my $state_fn  = File::Spec->catfile($ENV{HOME}, ".wt", "wt.state");
my $config = load_config($config_fn);
my $state  = load_state($state_fn);
my $ret = 0;

# precalculate workday and holiday hashes
my %holidays;
if (exists $config->{holidays} and ref $config->{holidays} eq 'ARRAY') {
	%holidays = map { ($_ => 1) } @{$config->{holidays}};
}
my %workdays;
if (exists $config->{workdays} and ref $config->{workdays} eq 'ARRAY') {
	%workdays = map { ($_ => 1) } @{$config->{workdays}};
}


# take care of encoding for output...
binmode STDOUT, ":encoding(UTF-8)";

# and for input as well
@ARGV = map { decode(locale => $_, 1) } @ARGV;

# get subcommand
my $action = shift @ARGV;

# take aliases into account
if (defined $action and exists $state->{aliases}{$action}) {
	my @cmds = @{$state->{aliases}{$action}};
	$action = shift @cmds;
	unshift @ARGV, @cmds;
}

# jump table for subcommands
for ($action) {
	when (undef)           { list_local(); }
	when ([qw/issues :/])  { get_issues(); }
	when ([qw/alias al/ ]) { set_alias();  }
	when ([qw/start  s/ ]) { set_mark();   }
	when ([qw/commit ci/]) { commit();     }
	when ([qw/report r/])  { query();      }
	when ([qw/help h/])    { help();       }
	when ([qw/push p/])    { pushout();    }
	when ("rm")            { rm();         }
	#when (/^[\-\d\+]/)     { unshift @ARGV, $action; add(); }
	default                { help();       }
}

exit($ret);

###############

sub help {
	my $action = shift // shift @ARGV // "";

	for ($action) {
		when (undef)           { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
		when ([qw/start s/])   { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/START"});  }
		when ([qw/alias al/ ]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ALIAS"});  }
		when ([qw/push p/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/PUSH"}); }
		when ([qw/issues :/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/ISSUES"}); }
		when ([qw/report r/])  { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/REPORT"}); }
		when ([qw/help h/])    { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/HELP"});   }
		when ([qw/commit ci/]) { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/COMMIT"});    }
		when ("rm")            { pod2usage({-verbose => 99, -sections => "SUBCOMMANDS/RM"});     }
		default                { pod2usage({-verbose => 99, -sections => "NAME|SYNOPSIS"});     }
	}

	exit;
}

sub list_local {
	my $i = 1;
	for my $wt (
		map {$_->[1]}
		sort { $a->[0] cmp $b->[0] }
		map { [(join "\t",
			_print_date($_->{date}),
			_print_time($_->{start_time}),
			_print_time($_->{end_time}) ), $_] }
		@{$state->{local}}) {
			print print_wtline($wt, $i++);
	}
	if (@{$state->{local}}) {
		say "";
		say summary($state->{local});
	}
	else {
		say "No local wt records.";
		$ret = 1;
	}

	print_unlogged();
	return;
}

sub set_alias {
	my $alias = shift @ARGV;

	if (defined $alias) {
		if (@ARGV) {
			$state->{aliases}{$alias} = [@ARGV];
		}
		else {
			delete $state->{aliases}{$alias};
		}
		save_state($state_fn, $state);
	}
	else {
		if (keys %{$state->{aliases}}) {
			while (my ($al, $def) = each %{$state->{aliases}}) {
				say $al, ":\t@$def";
			}
		}
		else {
			say "No defined aliases.";
			$ret = 1;
		}
	}
	return;
}

sub rm {
	my $remote = 0;
	GetOptions(
		'remote!'  => \$remote,
	) or help('rm');

	my $idx = shift @ARGV;
	if ($remote) {
		die "Error: specify the index of remote wt record to be deleted\n" unless $idx;
		die "Error: no remote wt records to delete\n" unless scalar @{$state->{remote}};

		my $pw = get_pw();

		if ($idx eq "all") {
			_rm_one_remote($_, $pw) for 0..$#{$state->{remote}};
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{remote}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{remote}};
			_rm_one_remote($idx-1, $pw);
		}
		# delete remote entries locally that were successfully deleted remotely
		$state->{remote} = [ grep { not exists $_->{deleted} } @{$state->{remote}} ];
		save_state($state_fn, $state);
		list_remote(on_error => "No remote worklog records.");
 	}
	else {
		die "Error: specify the index of local wt record to be deleted\n" unless $idx;
		die "Error: no local wt records to delete\n" unless scalar @{$state->{local}};

		if ($idx eq "all") {
			$state->{local} = [];
			say "All local wt records deleted!";
		}
		else {
			die "Error: index must be 1..".scalar @{$state->{local}}."\n" unless $idx =~ /^\d+$/ and $idx >= 1 and $idx <= scalar @{$state->{local}};
			# at this point we should have a valid index to delete
			splice @{$state->{local}}, $idx-1, 1;

			# update start mark to end of last entry
			if (@{$state->{local}}) {
				$state->{current_project} = $state->{local}[-1]{project};
				$state->{start_mark} = { t => $state->{local}[-1]{end_time}, d => $state->{local}[-1]{date} };
			}
		}
		save_state($state_fn, $state);
		list_local();
	}
	return;
}

sub get_common_options {
	my $options = {};
	Getopt::Long::Configure(qw/pass_through/);
	GetOptions($options, 'date=s', 'activity=s', 'message=s', 'issue=s', 'time=s');
	Getopt::Long::Configure(qw/no_pass_through/);
	return $options;
}

sub set_mark {
	my $change = 0;
	my $preserve = 0;

	my $options = get_common_options();
	GetOptions(
		'change' => \$change,
		'preserve' => \$preserve
	) or help('start');

	unless ($change) {
		$state->{start_mark} = { t => parse_time($options->{'time'}), d => parse_date($options->{date}) };
	}

	my $project_str = $options->{issue};
	if (defined $project_str) {
		$state->{current_project} = uc $project_str;
	} elsif (!$preserve) {
		$state->{current_project} = undef
	}

	if (defined($options->{message})) {
		$state->{current_comment} = $options->{message};
	} elsif (!$preserve) {
		$state->{current_comment} = undef;
	}
	if (defined($options->{activity})) {
		$state->{current_activity} = $options->{activity};
	} elsif (!$preserve) {
		$state->{current_activity} = undef;
	}

	if ($change) {
		print_unlogged();
	}
	else {
		say "Started work", _current_project();
	}

	save_state($state_fn, $state);
	return;
}

sub pushout {
	my $pw = get_pw();
	my $worklog_url = $config->{jira_base_url}.$config->{worklog_url};

	for my $wtline (@{$state->{local}}) {
		my $response = connect_to_jira(
			url     => $worklog_url,
			content => wtline_to_jira_json($wtline),
			pw      => $pw,
		);

		if ( $response->is_success() ) {
			# mark locally stored wt line if commit was successful
			$wtline->{committed} = 1;
		}
		else {
			_handle_jira_error($response);
		}
	}
	# delete wt lines that were successfully committed
	$state->{local} = [ grep { not exists $_->{committed} } @{$state->{local}} ];

	save_state($state_fn, $state);
	return;
}

sub query {
	my ($start_date_str, $end_date_str, $project) = @ARGV;

	if (defined $start_date_str) {
		my ($start_date, $end_date, $report_month_mode);

		if ($start_date_str eq 'month') {
			$report_month_mode = 'current';
			if (defined $end_date_str) {
				$end_date_str .= '-1'; # kludge to add fake day part to YYYY-MM input to be able to use parse_date
				$report_month_mode = 'historic';
			}
			($start_date, $end_date) = _get_month_start_end($end_date_str);
		}
		else {
			$start_date_str = undef if $start_date_str eq 'today';
			$start_date = parse_date($start_date_str);
			help('report') unless defined $start_date;

			$end_date = parse_date($end_date_str);
			$report_month_mode = 'custom_interval';
		}

		my %query_hash = (dateFrom => _print_date($start_date), dateTo => _print_date($end_date), username => $config->{user_name});
		$query_hash{projectKey} = $project if defined $project;
		my $query_string = uri_escape_hash(%query_hash);

		my $response = connect_to_jira(
			http_action => 'GET',
			url         => $config->{jira_base_url}.$config->{worklog_url}."?".$query_string,
		);

		if ( $response->is_success() ) {
			$state->{remote} = decode_json $response->decoded_content;

			update_saved_issue_summaries($state->{remote}, from => 'remote');

			$state->{cached_query_month_mode} = $report_month_mode;
			list_remote(
				on_error     => "No worklog records in the specified date range.",
				report_month => $report_month_mode,
				start_date   => $start_date,
				end_date     => $end_date);

			save_state($state_fn, $state);
		}
		else {
			_handle_jira_error($response);
		}

	}
	else {
		# print last saved query, don't actually ask jira
		list_remote(on_error => "There is no saved query.", report_month => 'cached');
	}
	return;

}

sub get_issues {
	my $assigned_to_me = 0;
	my $summary = 0;
	my $max = 100;
	my $raw_jql;
	GetOptions(
		'assigned!' => \$assigned_to_me,
		'summary!'  => \$summary,
		'max=i'     => \$max,
		'jql=s'     => \$raw_jql,
	) or help('issues');

	my $filter = shift @ARGV;
	my @jql;
	if (defined $filter) {
		if ($raw_jql) {
			push @jql, $filter;
		}
		elsif ($summary) {
			push @jql, "summary ~ $filter";
		}
		elsif ($filter =~ /\w+-\d+/) {
			push @jql, "issue = $filter";
		}
		else {
			push @jql, "project = $filter";
		}
	}
	if ($assigned_to_me) {
		push @jql, "assignee = " . $config->{user_name};
	}
	my $jql = join " and ", @jql;
	$jql .= " order by createddate desc" if $jql;

	my $response = connect_to_jira(
		url     => $config->{jira_base_url}.$config->{search_url},
		content => encode_json({
			"jql" => $jql,
			"startAt" => 0,
			"maxResults" => $max,
			"fields" => [
				"summary",
				"status",
				"assignee"
			]
		})
	);

	if ( $response->is_success() ) {
		my $raw_data = decode_json $response->decoded_content;
		say for reverse map {
				sprintf "%-8s%-16s%-16s%s",
					$_->{key},
					_trunc($_->{fields}{status}{name}, 15),
					$_->{fields}{assignee}{name} // "",
					$_->{fields}{summary}
				}
			@{$raw_data->{issues}};

		update_saved_issue_summaries($raw_data->{issues}, from => 'issuelist');
		save_state($state_fn, $state);
	}
	else {
		_handle_jira_error($response);
	}
	return;

}

sub commit {
	# defaults
	my $autocommit = 0;
	my $no_overlap_check = 0;
	my $activity = undef;

	# need to check if first arg is interval spec (single dash or dash-number)
	# before calling GetOptions
	my $options = get_common_options();
	# uses current date if no option given
	my $date = parse_date($options->{date});

	Getopt::Long::Configure(qw/no_ignore_case/);
	GetOptions(
		'yesterday' => sub { $date = _yesterday(); },
		'commit'    => \$autocommit,
		'force'     => \$no_overlap_check,
	) or help('commit');

	# first argument: from-to time or relative interval
	my $interval = $options->{'time'};
	my ($start_time, $end_time);
	if (!defined($interval) and !defined($state->{start_mark})) {
		die "Error: missing interval spec, and no start mark\n";
	}

	$interval //= '';
	# relative interval
	if (index($interval, '+') == 0) {
		if (defined $state->{start_mark}) {
			$start_time = $state->{start_mark}{t};
		}
		else {
			die "Error: no saved starting time available, you must specify the interval explicitly\n";
		}
		my $t = parse_time($interval);

		$end_time = increment_time($start_time, time_spent({H=>0, M=>0, S=>0}, $t));
	}
	# absolute interval
	else {
		my ($s, $e) = split '-', $interval;

		# If from is not specified, try to use saved start mark.
		# If there is no start mark either, give up.
		if (not defined $s or $s eq '') {
			if (defined $state->{start_mark}) {
				$start_time = $state->{start_mark}{t};
			}
			else {
				die "Error: no saved starting time available, you must specify it explicitly\n";
			}
		}
		else {
			$start_time = parse_time($s);
		}
		# end time falls back to current time if not specified
		$end_time = parse_time($e);
	}

	die "Error: ending time must be later than starting time\n" if time_spent($start_time, $end_time, noabs => 1) <= 0;

	# second argument: project
	my $project_str = $options->{issue};
	if (!defined($project_str) and !defined($state->{current_project})) {
		die "Error: issue name not found in arguments or start mark\n";
	}
	my $project;
	if (!defined $project_str) {
		$project = $state->{current_project};
		$project_str = $project;
	}
	if (!defined($project)) {
		$project_str //= '';
		if ($project_str eq "lunch") {
			# special hack: shortcut for lunch
			$project = $config->{lunch_project};
			die "Error: lunch project is not defined, edit wt.conf\n" unless defined $project;
		} else {
			$project = uc $project_str;
			$project_str //= "";
			die "Error: Invalid project name '$project_str', must be in PROJECT-NUMBER format\n" if $project !~ /^\w+-\d+$/;
		}
		$project = uc $project;
	}

	# third argument: comment
	# rest of @ARGV is concatenated so that quotes are not needed
	my $comment = $options->{message};
	# special hack: no comment is required for lunch
	$comment = "lunch" if !defined($comment) and $project_str eq "lunch";
	# use saved comment if one is available and explicitly requested
	$comment = $state->{current_comment} if !defined($comment) and defined $state->{current_comment};
	die "Error: Comment is required\n" if !defined($comment) or $comment eq '';
	# and save current comment for future use
	$state->{current_comment} = $comment unless $project_str eq 'lunch';

	# activity may have been set by option
	# special hack: no comment is required for lunch
	$activity = $options->{activity};
	$activity = $state->{current_activity} if (!defined($options->{activity}));
	$activity = "Break" if not defined $activity and $project_str eq "lunch";
	$activity //= 'Dev';

	# assemble ojject and save it
	my $wtline = {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $project,
		comment    => $comment,
		activity   => $activity,
	};

	if (not ($no_overlap_check or $config->{no_overlap_check})
	and my $overlap_idx = check_overlap($wtline)) {
		die "Error: input overlaps with existing entry:\n" .
			 print_wtline($state->{local}[$overlap_idx-1], $overlap_idx) .
			 print_wtline($wtline, undef) ."\n";
	}

	push @{$state->{local}}, $wtline;

	$state->{current_project} = $project unless $project_str eq 'lunch';
	$state->{start_mark} = { t => $end_time, d => $date };

	save_state($state_fn, $state);
	list_local();

	if ($autocommit or $config->{autocommit}) {
		commit();
	}
	return;
}

###############

sub _rm_one_remote {
	my $idx = shift;
	my $pw = shift;

	my $id = $state->{remote}[$idx]{id};

	my $response = connect_to_jira(
		http_action => 'DELETE',
		url     => $config->{jira_base_url}.$config->{worklog_url}.$id.'/',
		pw      => $pw,
	);

	if ( $response->is_success() ) {
		# mark locally stored remote entry if delete was successful
		$state->{remote}[$idx]->{deleted} = 1;
	}
	else {
		_handle_jira_error($response);
	}
	return;
}

###############

sub _load_json {
	my ($fn) = @_;
	local $/ = undef;
	open(my $FH, "<", $fn) or return; # undef
	my $json = <$FH>;
	close $FH;
	return decode_json $json;
}

sub _save_json {
	my ($fn, $obj, $what) = @_;
	if (open(my $FH, ">", $fn)) {
		print $FH encode_json $obj;
		close $FH;
	}
	else {
		warn "Error: can't write $what file $fn\n";
	}
	return;
}

sub load_config {
	my $config = _load_json($_[0]);
	die "Can't load config file $_[0]\n" unless $config;
	die "Missing key from config file: jira_base_url\n" unless defined $config->{jira_base_url};
	die "Missing key from config file: user_name\n" unless defined $config->{user_name};
	$config->{worklog_url} //=
		"/rest/tempo-timesheets/3/worklogs/";
	$config->{search_url}  //=
		"/rest/api/2/search";

	return $config;
}

sub load_state {
	my $state = _load_json($_[0], "state");
	return $state // { "local" => [], remote => [], start_mark => undef, current_project => undef };
}

sub save_state {
	_save_json($_[0], $_[1], "state");
	return;
}

###############

sub connect_to_jira {
	my %args = (
		http_action => 'POST',
		url         => undef,
		content     => '',
		pw          => undef,
		@_
	);

	my $pw = $args{pw} // get_pw();

	my $req = HTTP::Request->new($args{http_action}, $args{url});
	$req->header('Content-Type' => 'application/json;charset=UTF-8') if $args{http_action} eq 'POST';
	$req->authorization_basic($config->{user_name}, $pw);
	$req->content($args{content});

	my $ua = LWP::UserAgent->new;
	my $response = $ua->request($req);
	return $response;
}

###############

sub wtline_to_jira_json {
	my $wtline = shift;

	my $time_spent = time_spent($wtline->{start_time}, $wtline->{end_time});

	my $date_started = format_date($wtline->{date}, $wtline->{start_time});

	my $ojject = {
		issue => {
			key => uc $wtline->{project},
		},
		comment => $wtline->{comment},
		dateStarted => $date_started, #YYYY-MM-ddT00:00:00.000+0000
		timeSpentSeconds => $time_spent, #seconds
		billedSeconds => 0,
		worklogAttributes => [
			 {
			   'value' => $wtline->{activity},
			   'key' => '_Activity_'
			 }
        ],
		author => {
			name => $config->{user_name}
		},
	};

	my $json = encode_json($ojject);
	return $json;
}

sub jira_json_to_wtline {
	my $jira = shift;

	my ($ds, $ts) = split 'T', $jira->{dateStarted};
	my $date = parse_date($ds);
	my $start_time = parse_time($ts);
	my $end_time = increment_time($start_time, $jira->{timeSpentSeconds});

	return {
		start_time => $start_time,
		end_time   => $end_time,
		date       => $date,
		project    => $jira->{issue}{key},
		comment    => $jira->{comment},
		activity   => $jira->{worklogAttributes}[0]{value},
	};
}

sub print_wtline {
	my $wt = shift;
	my $idx = shift // 'X';

	return join "\t",
		$idx,
		_print_date($wt->{date}),
		_print_time($wt->{start_time}),
		_print_time($wt->{end_time}),
		$wt->{project},
		$wt->{comment},
		$wt->{activity},
		"\n";
}

sub uri_escape_hash {
    my %hash = @_;
    my @pairs;
    for my $key (keys %hash) {
        push @pairs, join "=", map { uri_escape($_) } $key, $hash{$key};
    }
    return join "&", @pairs;
}

sub update_saved_issue_summaries {
	my $issuelist = shift;
	my %args = @_;

	my %actions = (
		remote => sub {
				$state->{issues}->{ $_->{issue}{key} } = $_->{issue}{summary} for @_;
			},
		issuelist => sub {
				$state->{issues}->{ $_->{key} } = $_->{fields}{summary} for @_;
			}
	);
	if (defined $args{from} and exists $actions{ $args{from} }) {
		$actions{ $args{from} }->(@$issuelist);
	}
	return;
}

sub summary {
	my ($wt_arr, %args) = @_;

	my %times;
	my $cumulative_time = 0;
	for my $wt (@$wt_arr) {
		my $dt = time_spent($wt->{start_time}, $wt->{end_time});
		$times{ $wt->{project} } += $dt;
		$cumulative_time += $dt;
	}

	my $summary_lines = join "", map {
			sprintf("% 6.2f\t%s\t%s\n", ($times{$_}/3600), $_, (exists $state->{issues}{$_} ? $state->{issues}{$_} : ""))
		}
		sort {
			$times{$b} <=> $times{$a}
		}
		keys %times;

	my $cumulative_hours = $cumulative_time/3600;
	my $res_str = $summary_lines . "------\n" . sprintf "% 6.2f", $cumulative_hours;

	my $estimate_month = $args{report_month} // '';
	my $cached_mode = $estimate_month eq 'cached';
	if ($cached_mode and defined $state->{cached_query_month_mode}) {
		$estimate_month = $state->{cached_query_month_mode};
	}

	my %summary_annotations = (
		'current' => sub {
			my $today = parse_date();
			my ($start_month, $end_month) = _get_month_start_end();
			my $required_till_now        = _estimate_required_workday_hours($start_month, $today);
			my $required_till_end_month  = _estimate_required_workday_hours($start_month, $end_month);
			my $estimated_till_end_month = $required_till_end_month - $required_till_now + $cumulative_hours;
			return sprintf "/%.2f required, % 6.2f/%.2f estimated at the end of the month",
							$required_till_now,
							$estimated_till_end_month,
							$required_till_end_month;
		},
		'historic' => sub {
			my ($start_month, $end_month) = _get_month_start_end();
			my $required_till_end_month  = _estimate_required_workday_hours(
							$args{start_date} // $start_month,
							$args{end_date}  // $end_month);
			return sprintf "/%.2f required",
							$required_till_end_month;
		},
		'custom_interval' => sub {
			my $start_date = {Y => 2100, M => 1, D => 1};
			my $end_date   = {Y => 1900, M => 1, D => 1};
			for my $date (map { $_->{date} } @$wt_arr) {
				$start_date = $date if compare_dates($start_date, $date) > 0;
				$end_date   = $date if compare_dates($end_date,   $date) < 0;
			}
			my $required_in_interval = _estimate_required_workday_hours(
							$args{start_date} // $start_date,
							$args{end_date}  // $end_date);
			return sprintf "/%.2f required",
							$required_in_interval;
		},
	);
	$res_str .= $summary_annotations{$estimate_month}->() if exists $summary_annotations{$estimate_month};
	$res_str .= ' (cached query)' if $cached_mode;
	return $res_str;
}

sub list_remote {
	my %args = @_;
	my $i = 1;
	my @remote = @{$state->{remote}};
	for my $csira (@remote) {
		print print_wtline(jira_json_to_wtline($csira), $i++);
	}
	if (@remote) {
		say "";
		say summary([ map {jira_json_to_wtline($_)} @remote ], %args);
	}
	else {
		say $args{on_error};
		$ret = 1;
	}
	return;
}

sub print_unlogged {
	if (defined $state->{start_mark}) {
		my $today = parse_date(undef);
		my $saved = $state->{start_mark}{d};
		if ($today->{Y} == $saved->{Y} and
			$today->{M} == $saved->{M} and
			$today->{D} == $saved->{D} ) {

			my $interval = -1 * time_spent(parse_time(undef), $state->{start_mark}{t}, noabs => 1);
			if ($interval < 0) {
				say "End of last local wt entry is in the future";
			}
			else {
				my ($h, $m, $s);
				$h = int($interval / 3600); $interval -= $h * 3600;
				$m = int($interval /   60); $interval -= $m *   60;
				$s = int($interval);
				$interval = join ':', $h, pad($m), pad($s);
				say "Unlogged work: ", $interval, _current_project();
			}
		}
	}
	return;
}

sub _current_project {
	my $on_project = defined $state->{current_project} ?
						" on issue $state->{current_project}" :
						"";
	my $project_summary = defined $state->{current_project} && exists $state->{issues}->{ $state->{current_project} } ?
						"\t".$state->{issues}->{ $state->{current_project} } :
						"";
	my $comment = defined $state->{current_comment} && defined $state->{current_project} ?
						"\t($state->{current_comment})" :
						"";
	my $activity = defined $state->{current_activity} && defined $state->{current_project} ?
						"\t[$state->{current_activity}]" :
						"";

	return join "", $on_project, $project_summary, $comment, $activity;
}

sub _handle_jira_error {
	my $response = shift;

	warn "JIRA responded with ".$response->status_line."\n";
	if ($response->code() == 401) {
		forget_pw();
	}
	else {
		my $error = decode_json $response->decoded_content;
		say STDERR join "\n",
			@{$error->{errorMessages}}
			if exists $error->{errorMessages} and ref $error->{errorMessages} eq 'ARRAY' and @{$error->{errorMessages}};
		say STDERR join "\n",
			map { $_.": ".$error->{errors}->{$_} }
			keys %{$error->{errors}}
			if exists $error->{errors} and ref $error->{errors} eq 'HASH';
	}
	$ret = 1;
	return;
}

###############

sub _print_date {
	return join "-", map { pad($_[0]->{$_}) } qw/Y M D/;
}

sub _print_time {
	return join ":", map { pad($_[0]->{$_}) } qw/H M S/;
}

sub _wt2tfe {
	my ($t, $d) = @_;
	return timelocal(
		$t->{S}, $t->{M},   $t->{H},
		$d->{D}, $d->{M}-1, $d->{Y}
	);
}

sub check_overlap {
	my $new = shift;

	my $new_start = _wt2tfe($new->{start_time}, $new->{date});
	my $new_end   = _wt2tfe($new->{end_time},   $new->{date});

	my $i = 1;
	for my $wt (@{$state->{local}}) {
		my $wt_start = _wt2tfe($wt->{start_time}, $wt->{date});
		my $wt_end   = _wt2tfe($wt->{end_time},   $wt->{date});

		return $i unless (($new_start <= $wt_end and $new_end <= $wt_start) or ($new_start >= $wt_end and $new_end >= $wt_start));
		$i++;
	}

	return 0;
}

# get the first and last day of the current month (leap years accounted for)
sub _get_month_start_end {
	my $date_str = shift;
	my $today = parse_date($date_str);
	my $start = { %$today }; # deep copy
	my $end   = { %$today };

	$start->{D} = 1;
	$end->{D} = [undef, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]->[ $today->{M} ];
	if ($end->{M} == 2 and ($end->{Y} % 400 == 0 or ($end->{Y} % 100 != 0 and $end->{Y} % 4 == 0))) {
		$end->{D} = 29;
	}
	return $start, $end;
}

sub _estimate_required_workday_hours {
	my ($start_date, $end_date) = @_;

	my $sum_so_far = 0;
	my $day = DateTime->new(year => $start_date->{Y}, month => $start_date->{M}, day => $start_date->{D});
	my $end_DT = DateTime->new(year => $end_date->{Y}, month => $end_date->{M}, day => $end_date->{D});

	while ($day <= $end_DT) {
		my $dow = $day->day_of_week();
		my $dstr = sprintf "%02d-%02d", $day->month(), $day->day();
		my $is_workday = 1;
		$is_workday = 0 if $dow == 6 or $dow == 7 or exists $holidays{$dstr};
		$is_workday = 1 if exists $workdays{$dstr};
		$sum_so_far += 8 if $is_workday;
		$day->add(days => 1);
	}

	return $sum_so_far;
}

sub compare_dates {
	$_[0]->{Y} <=> $_[1]->{Y}
				||
	$_[0]->{M} <=> $_[1]->{M}
				||
	$_[0]->{D} <=> $_[1]->{D}
};


# if date is defined, try to parse it from YYYY-MM-DD or MM-DD or DD string, otherwise get current date
# if year or month is missing, it is substituted from current date
sub parse_date {
	my $dstr = shift;

	my @lt = localtime(time);
	my $date = {Y => $lt[5]+1900, M => $lt[4]+1, D => $lt[3]};

	if (defined $dstr and $dstr) {
		if ($dstr =~ /^ \d\d? $/x) {
			$date->{D} = 0+$dstr;
		}
		elsif ($dstr =~ /^ (\d\d?) - (\d\d?) $/x) {
			$date->{M} = 0+$1;
			$date->{D} = 0+$2;
		}
		elsif ($dstr =~ /^ (\d{4}) - (\d\d?) - (\d\d?) $/x) {
			$date->{Y} = 0+$1;
			$date->{M} = 0+$2;
			$date->{D} = 0+$3;
		}
		else {
			$date = undef;
		}

		unless (defined $date) {
			die "Invalid date specifier, must be one of YYYY-MM-DD or MM-DD or DD\n";
		}
	}
	return $date;
}

# if time is defined, try to parse it from HH-MM-SS or HH-MM or HH string, otherwise get current time
# if minutes or seconds are missing, they are assumed to be zero (whole hour/minute)
# +HH:MM or +HH.H or +MMm relative intervals are also parsed here
sub parse_time {
	my $dstr = shift;

	my @lt = localtime(time);
	my $time = {H => $lt[2], M => $lt[1], S => $lt[0]};

	my $is_interval = 0;
	if (defined $dstr and $dstr ne '') {
		if (index($dstr, '+') == 0) {
			substr($dstr, 0, 1, '');
			$is_interval = 1;
		}

		if ($is_interval and $dstr =~ /^ (\d\d?) \. (\d+) $/x) {
			$time->{H} = 0+$1;
			$time->{M} = int($2 * 6 + 0.5); # * 60 / 10
			$time->{S} = 0;
		}
		elsif ($is_interval and $dstr =~ /^ (\d+) m $/x) {
			my $m = 0+$1;
			$time->{H} = int($m / 60);
			$time->{M} = $m % 60;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^ (?: [0 1]? \d | 2 [0-3] ) $/x) {
			$time->{H} = 0+$dstr;
			$time->{M} = $time->{S} = 0;
		}
		elsif ($dstr =~ /^ ( [0 1]? \d | 2 [0-3] ) : ( [0-5]? \d ) $/x) {
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0;
		}
		elsif ($dstr =~ /^ ( [0 1]? \d | 2 [0-3] ) : ( [0-5]? \d ) : ( [0-5]? \d ) /x) { # drop fractional seconds
			$time->{H} = 0+$1;
			$time->{M} = 0+$2;
			$time->{S} = 0+$3;
		}
		else {
			$time = undef;
		}
		unless (defined $time) {
			if ($is_interval) {
				die "Invalid interval spec '$dstr', must be one of +HH:MM:SS, +HH:MM, +HH, +MMm\n";
			}
			else {
				die "Invalid time spec '$dstr', must be one of HH:MM:SS, HH:MM, HH\n";
			}
		}
	}
	return $time;
}

sub _trunc {
	my ($text, $len) = @_;
	my $shortened = $len - 3;
	return (length $text > $shortened) ? substr($text, 0, $shortened).'...' : $text;
}

sub pad {
	return ($_[0] < 10) ? '0'.$_[0] : $_[0];
}

sub format_date {
	my ($date, $time) = @_;

	my @lt = localtime(time);
	my $res = _print_date($date)
			. 'T'
			. _print_time($time);
			#. ($lt[8] ? '+2000' : '+1000');
	return $res;
}

sub time_spent {
	my ($start, $end, %args) = @_;

	$end->{M}   //= 0;
	$end->{S}   //= 0;
	$start->{M} //= 0;
	$start->{S} //= 0;

	my $e = $end->{H}   * 3600 + $end->{M}   * 60 + $end->{S};
	my $s = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};

	if (exists $args{noabs}) {
		return $e - $s;
	}
	else {
		return abs($e - $s);
	}
}

sub _yesterday {
	my $dt = DateTime->now()->subtract( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub _tomorrow {
	my $dt = DateTime->now()->add( days => 1 );
	return {Y => $dt->year(), M => $dt->month(), D => $dt->day()};
}

sub increment_time {
	my ($start, $increment) = @_;

	my $t = $start->{H} * 3600 + $start->{M} * 60 + $start->{S};
	$t += $increment;
	$t = 86400 if $t > 86400; # FIXME
	my $h = int($t / 3600);
	my $m = int($t / 60) % 60;
	my $s = $t % 60;
	return { H => $h, M => $m, S => $s };
}

sub get_pw {
	my $pw;
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$pw = $keyring->get_password($username, "wt_client");
		if(!$pw) {
			$pw = read_pw_from_console();
			$keyring->set_password($username, $pw, "wt_client");
		}
	}
	else {
		$pw = read_pw_from_console();
	}
	return $pw;
}

sub forget_pw {
	if ($have_keyring) {
		my $keyring = get_keyring(app=>"wt_client", group=>"wt_client");
		my $username = $config->{user_name};
		$keyring->clear_password($username, "wt_client");
	}
	return;
}

sub read_pw_from_console {
	ReadMode 2;
	print "JIRA Password:";
	my $pw = <STDIN>;
	ReadMode 0;
	print "\n";
	chomp $pw;
	return $pw;
}
